벌써, 2020년 2Q 시작.

# 04/04

## HackerRank

- 오랜만의 HackerRank.
- 문제는 [Roads and Libraries](https://www.hackerrank.com/challenges/torque-and-development/problem?h_l=interview&playlist_slugs%5B%5D=interview-preparation-kit&playlist_slugs%5B%5D=graphs).
- 일단 [실패하는 테스트 케이스로 뼈대 작성](https://github.com/codehumane/algorithm/commit/13ee91e20ecf167896feb4e8ef38726083d994b1).
- 다음으로, [isolated subgraphs가 없다고 가정하고 구현](https://github.com/codehumane/algorithm/commit/dccefc9b79126b2209dcda21d4309da99c0386b1).
- 마지막으로, [isolated subgraphs가 있다고 가정하고 구현](https://github.com/codehumane/algorithm/commit/ad7bc984ca705a52ee724346bb89b972a3a70be9).

# 04/05

## HackerRank

- 어제의 구현을 submit 해보면 일부 케이스 timeout이 발생.
- 공간을 좀 덜 쓰는 bfs로 바꿔 봄.
- `CityNode`라는 별도의 값 객체 사용 대신 `visited`와 `neibhgors`를 배열 사용하는 방식도 사용.
- 사용하는 컬렉션연산을 보면 당연히 의미 없음을 알고서도 [MutableSet 대신 Array로 바꿔보기도](https://github.com/codehumane/algorithm/commit/d400c63c197897da59c596dc6a9c8e0c0d962183).
- [2월에 겪었던 HackerRank의 문제](https://github.com/codehumane/what-i-learned/blob/master/til/2020-1Q.md#0202)인가 싶어서, [bfs라면 굳이 없어도 되는 `CityNode`의 value 필드를 제거해 보기도](https://github.com/codehumane/algorithm/commit/ada59d33064d7fe7de3b0db0646266ffa6537ae7) 함.
- 혹시나 싶어 [처음의 구현을 자바 버전으로 바꿔](https://github.com/codehumane/algorithm/commit/8863c422a182b2b2afd299f00037abbbced12bc3) submit 해보니, 바로 성공함.
- Kotlin은 아직도 지원이 부족한 듯.
- 내 아까운 시간 ㅠㅠ

# 04/07

## 코딩인터뷰 완전분석

- 바쁘다는 핑계로 뜸했는데 조금씩이라도 다시 읽으려 함.
- "[비트 조작](https://github.com/codehumane/what-i-learned/blob/master/book/ctci/README.md#%EB%B9%84%ED%8A%B8-%EC%A1%B0%EC%9E%91)" 추가.

# 04/14

## 코딩인터뷰 완전분석

- [2의 보수와 음수](https://github.com/codehumane/what-i-learned/blob/master/book/ctci/README.md#2%EC%9D%98-%EB%B3%B4%EC%88%98%EC%99%80-%EC%9D%8C%EC%88%98)
- [산술 우측 시프트 vs. 논리 우측 시프트](https://github.com/codehumane/what-i-learned/blob/master/book/ctci/README.md#%EC%82%B0%EC%88%A0-%EC%9A%B0%EC%B8%A1-%EC%8B%9C%ED%94%84%ED%8A%B8-vs-%EB%85%BC%EB%A6%AC-%EC%9A%B0%EC%B8%A1-%EC%8B%9C%ED%94%84%ED%8A%B8)
- [기본적인 비트 조작:비트값 확인 및 채워넣기](https://github.com/codehumane/what-i-learned/blob/master/book/ctci/README.md#%EA%B8%B0%EB%B3%B8%EC%A0%81%EC%9D%B8-%EB%B9%84%ED%8A%B8-%EC%A1%B0%EC%9E%91-%EB%B9%84%ED%8A%B8%EA%B0%92-%ED%99%95%EC%9D%B8-%EB%B0%8F-%EC%B1%84%EC%9B%8C%EB%84%A3%EA%B8%B0)

# 04/30

## HackerRank

### Ice Cream Parlor

- [Hash Tables: Ice Cream Parlor 풀이](https://github.com/codehumane/algorithm/commit/130752e7922fe205ab163e1cab1207492ee7b62e)
- Kotlin 버전으로 작성했는데 Submit 하면 다 틀리다고 나옴.
- 아무리 봐도 이상해서 Java 버전으로 바꿔서 Submit 하면 성공함.
- 여러 번 문제를 겪고 나니, 다음부터는 Java로 풀기로.

### Pairs

- 이번엔 그냥 처음부터 Java로 작성함.
- [깊게 생각 안 하고 일단 풀이](https://github.com/codehumane/algorithm/commit/1fd527df12c1d57d563e974b542321b71dca695b)
- [살짝 코드 개선](https://github.com/codehumane/algorithm/commit/278a88d981ce87de35a0c755f0427b92bf8423dc)

# 05/01

## HackerRank

### Triple Sum

- [성능 고려 안 하고 일단 구현](https://github.com/codehumane/algorithm/commit/e1cb6fe7f72c0f93e343acd1af642f8e597d3b94)
- [성능 개선](https://github.com/codehumane/algorithm/commit/b5f48f32f6712b70d4e00779c60c4330e690aaac)
- [마지막으로 간단히 리팩토링](https://github.com/codehumane/algorithm/commit/cc7f3d990a5f27176a082d2d9b679be394baef75)

# 05/03

## 코딩인터뷰 완전분석

- [수학 및 논리 퍼즐](https://github.com/codehumane/what-i-learned/blob/master/book/ctci/README.md#%EC%88%98%ED%95%99-%EB%B0%8F-%EB%85%BC%EB%A6%AC-%ED%8D%BC%EC%A6%90).
- 가장 먼저 [소수](https://github.com/codehumane/what-i-learned/blob/master/book/ctci/README.md#%EC%86%8C%EC%88%98) 이야기.
- 다음으로 [확률](https://github.com/codehumane/what-i-learned/blob/master/book/ctci/README.md#%ED%99%95%EB%A5%A0) 이야기.
- 나머지 내용은 기록 생략.

# 05/05

## HackerRank

### Minimum Time Required

- [brute force로 먼저 구현](https://github.com/codehumane/algorithm/commit/bc245a1525808beff8963f5cf4fcee2b5056e1e5).
- 매일 매일을 확인하는 것.

# 05/07

## 코딩인터뷰 완전분석

- [재귀와 동적 프로그래밍](https://github.com/codehumane/what-i-learned/blob/master/book/ctci/README.md#%EC%9E%AC%EA%B7%80%EC%99%80-%EB%8F%99%EC%A0%81-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)
- [피보나치 재귀](https://github.com/codehumane/what-i-learned/blob/master/book/ctci/README.md#%EC%9E%AC%EA%B7%80)
- [피보나치 하향식 동적 프로그래밍](https://github.com/codehumane/what-i-learned/blob/master/book/ctci/README.md#%ED%95%98%ED%96%A5%EC%8B%9D-%EB%8F%99%EC%A0%81-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%A9%94%EB%AA%A8%EC%9D%B4%EC%A0%9C%EC%9D%B4%EC%85%98)

# 05/08

## 코딩인터뷰 완전분석

- [피보나치 상향식 동적 프로그래밍](https://github.com/codehumane/what-i-learned/blob/master/book/ctci/README.md#%EC%83%81%ED%96%A5%EC%8B%9D-%EB%8F%99%EC%A0%81-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)

# 05/15

## HackerRank

### Minimum Time Required

- Brute Force로 구현했던 것을 [Binary Search 방식으로 개선](https://github.com/codehumane/algorithm/commit/2279cb5fc9fd221b6e5b4ee151f333ed462577fb)
- 시간 복잡도는 O(n * log n).

# 05/18

## HackerRank

### Swap Nodes

- [일단 트리 구성하고 탐색하는 로직 구현](https://github.com/codehumane/algorithm/commit/a488bb1d276100ca605f22cccec907aa67a26143)
- [구성된 트리를 swap 하는 로직 추가](https://github.com/codehumane/algorithm/commit/3dc8dfda684df4862859b7febccccf2d30831ba7)
- 중복된 원소를 포함하지 않는 트리. 그리고 균형 트리 아님.
- in-order traversal.

# 05/22

## HackerRank

### Making Candies

- 최근 들어 가장 어려웠던 문제.
- [일단 성능 고려 없이 1차 구현](https://github.com/codehumane/algorithm/commit/136dbbc2c525b787dfc99fb2f5021d73a01add83)
- 하지만, 실패하는 케이스가 있었음.
- machine이나 worker를 늘리는 게 의미 없는 경우가 있는데, 너무 좁은 범위에 대해서만 처리하고 있어서 문제.
- [그래서 좀 더 일반화 된 판단 로직으로 수정](https://github.com/codehumane/algorithm/commit/71b67732f6c0b7dea0ec0929053d08b08b194bfd)
- [그러고 나서 곱셈이 overflow 나는 경우 고려 추가](https://github.com/codehumane/algorithm/commit/98361fefad61650171e12e9bbeb797c70bc32d5e)
- 여기까지 하고 나니 틀리는 문제는 없었음.
- 이제 성능 개선할 차례.
- 가장 먼저, [machines과 worker 늘리는 처리를 루프 없이 가능하게 변경](https://github.com/codehumane/algorithm/commit/30156139de96eb854d53c48c00ab850360be6d9d)
- 다음으로, [machine이나 worker를 늘릴 수 없는 경우의 루프를 최소화](https://github.com/codehumane/algorithm/commit/8f7ee061ebb5b79b29070620d3b30eeb78ccf050)
- 그제서야 모든 케이스가 통과함.

# 05/28

## HackerRank

### Maximum Subarray Sum

- 일단 문제는 [여기](https://www.hackerrank.com/challenges/maximum-subarray-sum/problem) 참고.
- [brute force로 먼저 구현](https://github.com/codehumane/algorithm/commit/0ea2912104c3dc2fe2574b222a7ce947c051a64b).
- 다음으로 [성능 개선 버전 구현](https://github.com/codehumane/algorithm/commit/bd20fb9fa3e7d554513129a29769cfbdbfa3ffe9).
- 핵심은 배열의 prefix sum(+modulo)을 이용.
- 더불어, 현재 루프의 prefix sum보다 큰 prefix sum 중에 최소값을 찾아야 함. 아래 규칙 때문임.
- `max = A(현재 원소까지의 prefix sum) - B(현재까지 모은 prefix sum 중에 A보다 큰 최소값)`
- 예컨대 아래의 경우에서, 3번째 원소에 대해 루프를 돌고 있다면, 1번째 prefix를 찾아야 함.
- balanced binary search tree 활용.
- 이를 통해, O(N * logN)을 기대할 수 있음.

```
modulus     = 5
array       = [7,1,3]
prefix sum  = [2,3,1]
```

## TreeSet

- [Maximum Subarray Sum](https://www.hackerrank.com/challenges/maximum-subarray-sum/problem) 풀다가 [`TreeSet`](https://docs.oracle.com/javase/7/docs/api/java/util/TreeSet.html) 간단히 정리.
- [`NavigableSet`](https://docs.oracle.com/javase/7/docs/api/java/util/NavigableSet.html)의 구현체이며, [`TreeMap`](https://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html)을 기반으로 함.
- `NavigableSet`은 [`SortedSet`](https://docs.oracle.com/javase/7/docs/api/java/util/SortedSet.html) 인터페이스의 확장이며, navigation methods를 추가로 제공.
- 주어진 대상과 근접한 값을 찿아내는 `lower`, `floor`, `ceiling`, `higher` 같은 것들이 그 메서드.
- `NavigableSet`은 근접한 것을 찾아내기 위해 원소들을 정렬상태로 유지.
- 정렬 시에는 원소의 [natural ordering](https://docs.oracle.com/javase/7/docs/api/java/lang/Comparable.html)을 사용할 수도 있고, 생성자에 주어진 [`Comparator`](https://docs.oracle.com/javase/7/docs/api/java/util/Comparator.html)를 이용할 수도.
- 기본 연산(`add`, `remove`, `contains`)에 대해 log(n) 보장.
- "Note that this implementation is not synchronized."
- 따라서 `Collections.synchronizedSortedSet(new TreeSet(...))` 등의 장치가 필요할 수도.

# 06/08

## 코딩인터뷰 완전분석

- [정렬과 탐색](https://github.com/codehumane/what-i-learned/blob/master/book/ctci/README.md#%EC%A0%95%EB%A0%AC%EA%B3%BC-%ED%83%90%EC%83%89)
- 기수 정렬도 당연히 알아야 하는 구나 윽.


# 06/09

## 코딩인터뷰 완전분석

- [테스팅](https://github.com/codehumane/what-i-learned/blob/d0491c5b38a22c7b54a6ae0d0dfa38ee259908c1/book/ctci/README.md#%ED%85%8C%EC%8A%A4%ED%8C%85)
- 면접이라는 컨텍스트를 벗어나도 의미 있는 이야기.

