# 01/03

- [[도메인 주도 설계 핵심] 컨텍스트 매핑과 전략적 설계](https://github.com/codehumane/what-i-learned/tree/master/dddd#컨텍스트-매핑과-전략적-설계)

# 01/05

- UDP 연결 여부 확인이 필요해서 참고한 ["How does netcat know if a UDP port is open?"](https://unix.stackexchange.com/questions/235830/how-does-netcat-know-if-a-udp-port-is-open)
- [NewRelic](https://newrelic.com/)은 유료라 모든 서비스의 인스턴스에 사용하지는 않음. 따라서, 대안으로 [Pinpoint](https://github.com/naver/pinpoint) 적용함.

# 01/07

- [[도메인 주도 설계 핵심] 애그리게잇과 전술적 설계](https://github.com/codehumane/what-i-learned/blob/master/dddd/README.md#애그리게잇과-전술적-설계)
- [[알고리즘] 그래프의 경로](https://github.com/codehumane/what-i-learned/blob/master/algorithm/paths-in-graph.md)
- [유니버설 해싱](https://github.com/codehumane/what-i-learned/blob/master/algorithm/number-algorithm.md#유니버설-해싱)에 대해 다시 살펴봄.
- [넓이 우선 탐색<sup>Breath First Search</sup>를 통한 거리 구하기 구현](https://github.com/codehumane/learn-algorithm-in-java/commit/3f5fa5d702adc5b46820e705f387598d5219a54e)

# 01/13

- [[알고리즘] 그래프의 경로](https://github.com/codehumane/what-i-learned/blob/master/algorithm/paths-in-graph.md#%EA%B7%B8%EB%9E%98%ED%94%84%EC%9D%98-%EA%B2%BD%EB%A1%9C)
  - [간선의 길이](https://github.com/codehumane/what-i-learned/blob/master/algorithm/paths-in-graph.md#%EA%B0%84%EC%84%A0%EC%9D%98-%EA%B8%B8%EC%9D%B4)
  - [데이크스트라 알고리즘](https://github.com/codehumane/what-i-learned/blob/master/algorithm/paths-in-graph.md#%EB%8D%B0%EC%9D%B4%ED%81%AC%EC%8A%A4%ED%8A%B8%EB%9D%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)

# 01/14

- [[알고리즘] 그래프의 경로 - 우선순위 큐 구현](https://github.com/codehumane/what-i-learned/blob/master/algorithm/paths-in-graph.md#%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%ED%81%90-%EA%B5%AC%ED%98%84)

# 01/17

- `com.netflix.niws.client.http.RestClient`를 사용하는 코드에서 예외 발생시 HTTP 연결 종료 코드가 누락됨을 발견.
- 이로 인해 많은 CLOSE_WAIT이 누적됨. 스레드 덤프에는 많은 Hystrix Thread 들이 WAIT 상태.
- 구조상 주로 개발환경에서 발생했지만, 불필요한 비용이 되어버림.
- 참고로, [CLOSE_WAIT & TIME_WAIT 최종분석](http://tech.kakao.com/2016/04/21/closewait-timewait/)의 아래 문장은 도움이 됨.

> "한 가지 주의할 점은 클라이언트와 서버 대신 Active Close와 Passive Close라는 >표현을 사용한 것인데, 반드시 서버만 CLOSE_WAIT 상태를 갖는 것은 아니기 때문입니>다. 서버가 먼저 종료하겠다고 FIN을 보낼 수 있고, 이런 경우 서버가 FIN_WAIT1 상태
가 됩니다. 따라서, 클라이언트와 서버가 아닌 Active Close(또는 Initiator, 기존 클
라이언트)와 Passive Close(또는 Receiver, 기존 서버)정도로 표현하는 것이 정확합니
다."

