# 01/03

- [[도메인 주도 설계 핵심] 컨텍스트 매핑과 전략적 설계](https://github.com/codehumane/what-i-learned/tree/master/dddd#컨텍스트-매핑과-전략적-설계)

# 01/05

- UDP 연결 여부 확인이 필요해서 참고한 ["How does netcat know if a UDP port is open?"](https://unix.stackexchange.com/questions/235830/how-does-netcat-know-if-a-udp-port-is-open)
- [NewRelic](https://newrelic.com/)은 유료라 모든 서비스의 인스턴스에 사용하지는 않음. 따라서, 대안으로 [Pinpoint](https://github.com/naver/pinpoint) 적용함.

# 01/07

- [[도메인 주도 설계 핵심] 애그리게잇과 전술적 설계](https://github.com/codehumane/what-i-learned/blob/master/dddd/README.md#애그리게잇과-전술적-설계)
- [[알고리즘] 그래프의 경로](https://github.com/codehumane/what-i-learned/blob/master/algorithm/paths-in-graph.md)
- [유니버설 해싱](https://github.com/codehumane/what-i-learned/blob/master/algorithm/number-algorithm.md#유니버설-해싱)에 대해 다시 살펴봄.
- [넓이 우선 탐색<sup>Breath First Search</sup>를 통한 거리 구하기 구현](https://github.com/codehumane/learn-algorithm-in-java/commit/3f5fa5d702adc5b46820e705f387598d5219a54e)

# 01/13

- [[알고리즘] 그래프의 경로](https://github.com/codehumane/what-i-learned/blob/master/algorithm/paths-in-graph.md#%EA%B7%B8%EB%9E%98%ED%94%84%EC%9D%98-%EA%B2%BD%EB%A1%9C)
  - [간선의 길이](https://github.com/codehumane/what-i-learned/blob/master/algorithm/paths-in-graph.md#%EA%B0%84%EC%84%A0%EC%9D%98-%EA%B8%B8%EC%9D%B4)
  - [데이크스트라 알고리즘](https://github.com/codehumane/what-i-learned/blob/master/algorithm/paths-in-graph.md#%EB%8D%B0%EC%9D%B4%ED%81%AC%EC%8A%A4%ED%8A%B8%EB%9D%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)

# 01/14

- [[알고리즘] 그래프의 경로 - 우선순위 큐 구현](https://github.com/codehumane/what-i-learned/blob/master/algorithm/paths-in-graph.md#%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%ED%81%90-%EA%B5%AC%ED%98%84)

# 01/17

## Netflix HttpResponse & CLOSE_WAIT

- `com.netflix.niws.client.http.RestClient`를 사용하는 코드에서 예외 발생시 HTTP 연결 종료 코드가 누락됨을 발견.
- `RestClient`의 응답은 [HttpResponse](https://github.com/Netflix/ribbon/blob/master/ribbon-httpclient/src/main/java/com/netflix/client/http/HttpResponse.java)라는 `Closeable`의 구현체.
- 이로 인해 많은 CLOSE_WAIT이 누적됨. 스레드 덤프에는 많은 Hystrix Thread 들이 WAIT 상태.
- 구조상 주로 개발환경에서 발생했지만, 불필요한 비용이 되어버림.
- 참고로, [CLOSE_WAIT & TIME_WAIT 최종분석](http://tech.kakao.com/2016/04/21/closewait-timewait/)의 아래 문장은 도움이 됨.

> "한 가지 주의할 점은 클라이언트와 서버 대신 Active Close와 Passive Close라는 표현을 사용한 것인데, 반드시 서버만 CLOSE_WAIT 상태를 갖는 것은 아니기 때문입니다. 서버가 먼저 종료하겠다고 FIN을 보낼 수 있고, 이런 경우 서버가 FIN_WAIT1 상태가 됩니다. 따라서, 클라이언트와 서버가 아닌 Active Close(또는 Initiator, 기존 클라이언트)와 Passive Close(또는 Receiver, 기존 서버)정도로 표현하는 것이 정확합니다."

# 01/18

## Spring Cloud Bootstrap Application Context

- [EnvironmentPostProcessor](https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/env/EnvironmentPostProcessor.html)를 통해 외부 시스템의 프로퍼티를 가져오는 코드가 있었음.
- 외부 시스템의 접속 정보는 `application.yml`에 변수로 지정하고 외부로부터 값을 주입.
- 그런데, [Spring Cloud Consul](https://cloud.spring.io/spring-cloud-consul/) 적용시, `EnvironmentPostProcessor`에서 외부 시스템의 접속 정보를 주입 받지 못함.
- `bootstrap.yml`을 통해 외부 시스템의 접속 정보를 주입 받는 것으로 해결.
- 처음엔 어색했으나 `bootstrap.yml`을 왜 쓰는지 생각해보면 자연스러움.
- Bootstrap Application Context에 대해서는 [여기](https://cloud.spring.io/spring-cloud-static/spring-cloud.html#_the_bootstrap_application_context)를 참고.

> The bootstrap context uses a different convention for locating external configuration than the main application context, so instead of `application.yml` (or `.properties`) you use `bootstrap.yml`, keeping the external configuration for bootstrap and main context nicely separate.

## Terraform

- [What is Terraform](https://www.terraform.io/intro/index.html)
- [Install Terraform](https://www.terraform.io/intro/getting-started/install.html)
- [Build Infrastructure](https://www.terraform.io/intro/getting-started/build.html)
- [집에 있어도 뭐라도 작성해 보자고 만든 리포지토리](https://github.com/codehumane/terraform-tools)

# 01/19

## Spring Bean Conditional Registration

-  [@Profile](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-profiles.html)은 AND 조건을 지원 X.
-  이런 경우 좀 더 일반화된 [@Conditional](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Conditional.html)을 사용.
-  [여기](https://javapapers.com/spring/spring-conditional-annotation/)에도 설명이 잘 나와 있음.


# 01/21

- [배열을 활용한 우선순위 큐 구현](https://github.com/codehumane/learn-algorithm-in-java/commit/36cdd89ffef6f27d0d375e15990ed4dd9b3943f9)

# 01/23

[프로세스와 스레드, NIO, 그리고 리액티브 스트림](https://www.youtube.com/watch?v=5KttCnoWLhs) 보면서 기록.

- 먼저 프로세스와 스레드 이야기.
  - 오랜만에 프로세스와 스레드 각각의 공간을 살핌. 좀 더 자세한 내용은 [여기](https://www.programcreek.com/2013/04/jvm-run-time-data-areas/) 참고. 각각이 가지는 공간으로 스레드 생성과 프로세스 생성의 비용 비교 가능. 물론, 데이터 공유 가능 여부도.
  - 그 밖에, 컨텍스트 스위칭 비용(cpu register 상태 저장과 복원), 캐시(CPU와 RAM 사이의 IO) 공유, 스레드 풀과 큐.
- 다음으로 [CompletableFuture](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html) 이야기.
  - 처음에는 [Thread](https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html)와 [Runnable](https://docs.oracle.com/javase/7/docs/api/java/lang/Runnable.html)에서 시작.
  - 그리고 좀 더 추상화된 [Future](https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html) 언급. 하지만 의존성이 있는 작업의 처리나, 스레드 풀 관리 등의 문제 존재.
  - 미려한 API를 제공하는 [CompletableFuture](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html)의 `thenApply`, `thenCombine`, `thenApplyAsync` 소개.
- 그리고 NIO 이야기.
  -  여전히 해결하지 못하는 스레드 풀 꽉차는 문제.
  - 그래서 Nonblocking I/O를 언급. New IO의 한 피처(그 외는 Native IO).
  - Servlet에서의 Nonblocking I/O는 [DeferredResult](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/context/request/async/DeferredResult.html)로 언급을 대체.
- 마지막 리액티브는 정리할 만한 내용은 아님.

