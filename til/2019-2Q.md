# 04/28

다시 TIL 시작. 최근에는 꼭 배운 것을 모두 기록할 필요는 없겠다고 생각중. 하지만 다시 한 번 더 해보고 생각해 보려 함.

## Reactive Programming with RxJava

### [How RxJava Works](<https://github.com/codehumane/what-i-learned/tree/master/book/reactive-programming-with-rxjava#how-rxjava-works>)

동시성과 병렬성의 구분, 사람이 쓰기 좋게 API를 설계하려는 노력, Lazy 특성으로 인해 조합이 가능해지는 것, 쌍대성의 의미, API로 카디널리티를 구분하려는 의도 등이 인상 깊었음.

- [Concurrency and Parallelism](https://github.com/codehumane/what-i-learned/tree/master/book/reactive-programming-with-rxjava#concurrency-and-parallelism)
- [Lazy versus Eager](https://github.com/codehumane/what-i-learned/tree/master/book/reactive-programming-with-rxjava#lazy-versus-eager)
- [Duality](<https://github.com/codehumane/what-i-learned/tree/master/book/reactive-programming-with-rxjava#duality>)
- [Cardinality](<https://github.com/codehumane/what-i-learned/tree/master/book/reactive-programming-with-rxjava#cardinality>)

# 04/29

- [그래프 탐색](https://github.com/codehumane/what-i-learned/tree/master/book/algorithms-explained-animated#%EA%B7%B8%EB%9E%98%ED%94%84-%ED%83%90%EC%83%89)
- [Mechanical Sympathy: Blocking versus Nonblocking I/O](https://github.com/codehumane/what-i-learned/tree/master/book/reactive-programming-with-rxjava#mechanical-sympathy-blocking-versus-nonblocking-io)

# 04/30

[Project Reactor의 Learn 페이지](https://projectreactor.io/learn)를 부분을 보면 여러 가이드가 있음. 그 중에서도, [Lite Rx API Hands On](https://tech.io/playgrounds/929/reactive-programming-with-reactor-3/Intro), [Head-First Spring and Reactor Reactive Workshop](https://github.com/reactor/head-first-reactive-with-spring-and-reactor/tree/start/docs)이 괜찮아 보임. 하나씩 보며 기록할 예정. 첫 번째로는 [Introduction to Reactive Programming](https://github.com/codehumane/what-i-learned/blob/master/document/reactive-programming-with-reactor-3.md#introduction-to-reactive-programming)를 정리함.

# 05/01

## Designing Data-Intensive Application

- [Unreliable Clocks > Process Pauses](https://github.com/codehumane/what-i-learned/blob/master/book/ddia/Distributed-Data.md#process-pauses)

# 05/06

## Designing Data-Intensive Application

### Knowledge, Truth, and Lies

[The truth Is Defined by the Majority](https://github.com/codehumane/what-i-learned/blob/master/book/ddia/Distributed-Data.md#the-truth-is-defined-by-the-majority)

단일 노드에 의존하는 것이 주는 많은 문제점 소개. 그래서 정족수<sup>quorum</sup>에 의존한다는 얘기(앞선 내용들에서 이미 많이 언급됨). 그리고, lock 또는 lease가 해결하는 것과 한계점. Fencing Token을 이용해 한계를 극복한다는 얘기까지(단점도 언급).

## Lite Rx API Hands On

- [Learn how to create Flux instances](https://github.com/codehumane/what-i-learned/blob/master/document/reactive-programming-with-reactor-3.md#learn-how-to-create-flux-instances)
- [Learn how to create Mono instances](https://github.com/codehumane/what-i-learned/blob/master/document/reactive-programming-with-reactor-3.md#learn-how-to-create-mono-instances)

# 05/07

## Lite Rx API Hands On

`StepVerifier`는 `reactor-test` artifact라고 함. 말 그대로 테스트, 검증을 위한 것. `map`, `flatMap`에 대한 소개는 별 것 없을거라 생각했는데, `flatMap`이 async transformation이라는 말이 와 닿음. flat 하게 만들어 줄 뿐만 아니라, 비동기이기도 한 것(이로 인해 순서 보장이 되지 않음).

- [StepVerifier and how to use it](https://github.com/codehumane/what-i-learned/blob/master/document/reactive-programming-with-reactor-3.md#stepverifier-and-how-to-use-it)
- [Learn to transform our asynchronous data](https://github.com/codehumane/what-i-learned/blob/master/document/reactive-programming-with-reactor-3.md#learn-to-transform-our-asynchronous-data)

# 05/08

- Lite Rx API Hands On, [Merge](https://github.com/codehumane/what-i-learned/blob/master/document/reactive-programming-with-reactor-3.md#merge)

# 05/09

backpressure(volume control)에 대한 이야기. 수요를 제어하기 위한, `Subscriber`-> `Publisher` 피드백 메커니즘.

- Lite Rx API Hands On, [Request](https://github.com/codehumane/what-i-learned/blob/master/document/reactive-programming-with-reactor-3.md#request)

# 05/10

Reactor 3에서 에러가 발생했을 때, 폴백 처리를 하거나, Checked Exception이 발생한 경우에 대한 처리를 소개하고 있음.

- Lite Rx API HAnds On, [Error](https://github.com/codehumane/what-i-learned/blob/master/document/reactive-programming-with-reactor-3.md#error)

[Reactor 3 Reference Guide](https://projectreactor.io/docs/core/release/reference/)는 역시나 잘 정리된 문서라고 생각됨.

# 05/11

[Byzantine Faults](https://github.com/codehumane/what-i-learned/blob/master/book/ddia/Distributed-Data.md#byzantine-faults). 분산 시스템 환경에서, 노드가 신뢰할 수 없을 뿐만 아니라(unreliable), "거짓말"을 할 수도 있는 경우에 대한 이야기. 이런 상황에서 어떻게 합의를 이끌어 낼 것이냐에 대한 이야기. 일반적인 웹 애플리케이션 개발에는 문제가 되지 않지만, Peer-to-Peer 환경에서는 문제가 될 수도. Byzantine Fault Tolerant에도 여전히 전통적인 인증, 인가, 인크립션, 방화벽 등의 Weak forms of lying 극복은 중요함을 강조.

# 05/15

## Lite Rx API Hands Om

- [Adapt](https://github.com/codehumane/what-i-learned/blob/master/document/reactive-programming-with-reactor-3.md#adapt) 정리. 아래의 변환에 대해 다룸.
    - `Flux` <-> `Flowable`
    - `Flux` <-> `Observable`
    - `Mono` <-> `Single`
    - `Mono` <-> `CompletableFuture`
- 이들 모두 별도의 외부 라이브러리 없이 가능.

## MySQL binlog

MySQL binlog 정보 가져올 때의 이슈들.

- [Could not find first log file name in binary log index file](https://blog.tinned-software.net/mysql-could-not-find-first-log-file-name/)
- [max_allowed_packet and binary log corruption in MySQL](https://www.percona.com/blog/2014/05/14/max_allowed_packet-and-binary-log-corruption-in-mysql/)

`log event entry exceeded max_allowed_packet`라는 오류 메시지를 만남. max_allowed_packet에 대한 설명은 [MySQL 레퍼런스](https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_max_allowed_packet) 참고. 이 문제는 binlog position 값이 잘못되어 발생할 수도. binlog position 값의 구성은 타임스탬프(4바이트) + 타입코드(2바이트) + 서버아이디(4바이트) + 길이(4바이트) + 다음포지션(4바이트). 따라서, 잘못된 값이 들어가면 길이 부분의 값이 max_allowed_packet 보다 클 수 있고, max_allowed_packet 제약 문제를 만날 수 있음.

# 05/16

## Lite Rx API Hands On

- [Other Operations](https://github.com/codehumane/what-i-learned/blob/master/document/reactive-programming-with-reactor-3.md#other-operations) 정리
- Flux#zip, Flux#first, Mono#first, Flux#ignoreElements, Flux#then, Mono#justOrEmpty, Mono#defaultIfEmpty 등을 소개.
- Reactive Stream에서는 emit 하는 값으로 null을 허용하지 않는 것으로 보임. 아래 코드들 참고.

```java
// Mono#doOnNext
public final Mono<T> doOnNext(Consumer<? super T> onNext) {
  Objects.requireNonNull(onNext, "onNext");
  return doOnSignal(this, (Consumer)null, onNext, (Consumer)null, (Runnable)null, (LongConsumer)null, (Runnable)null);
}

// MonoJust
MonoJust(T value) {
    this.value = Objects.requireNonNull(value, "value");
}
```

