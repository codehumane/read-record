# 08/04

## Designing Data-Intensive Applications

- [Single-leader replication and consensus](https://github.com/codehumane/what-i-learned/blob/master/book/ddia/Distributed-Data.md#single-leader-replication-and-consensus)
- [Epoch numbering and quorums](https://github.com/codehumane/what-i-learned/blob/master/book/ddia/Distributed-Data.md#epoch-numbering-and-quorums)

# 08/09

## Designing Data-Intensive Applications

- [Limitations of consensus](https://github.com/codehumane/what-i-learned/blob/master/book/ddia/Distributed-Data.md#limitations-of-consensus)

# 08/11

## Designing Data-Intensive Applications

- [Membership and Coordination Services](https://github.com/codehumane/what-i-learned/blob/master/book/ddia/Distributed-Data.md#membership-and-coordination-services)

# 08/14

## Designing Data-Intensive Applications

- [Allocating work to nodes](https://github.com/codehumane/what-i-learned/blob/master/book/ddia/Distributed-Data.md#allocating-work-to-nodes)
- [Service discovery](https://github.com/codehumane/what-i-learned/blob/master/book/ddia/Distributed-Data.md#service-discovery)
- [Membership services](https://github.com/codehumane/what-i-learned/blob/master/book/ddia/Distributed-Data.md#membership-services)

# 08/19

- [Consistency and Consensus의 요약](https://github.com/codehumane/what-i-learned/blob/master/book/ddia/Distributed-Data.md#summary-1)
- [블로그에도 기록](http://codehumane.github.io/2019/08/13/Consistency-and-Consensus/)

# 08/22

빠르게 <[커리어 스킬](http://www.yes24.com/Product/Goods/71829578)>을 읽음. 기록하면서 읽을 정도의 책도, 정독할 만한 책도 아니어서 빠르게 읽음. 책은 별로였지만 적어도 자극은 된 듯 하다. 주변에 추천하고 싶지는 않음.

# 08/25

남은 하반기(어느덧 올해도 4개월 밖에 안 남음)를 좀 더 계획적으로 보내고자 [MILESTONE](https://github.com/codehumane/milestone/blob/master/MILESTONE.md) 이라는 문서를 작성함. 계획 수립과 진도 체크는 링크된 문서에서 진행할 예정. 여기에도 간단히 적어보면, 일단 카테고리는 5개.

- [ ] 도서
- [ ] 도큐먼트
- [ ] 알고리즘
- [ ] 커뮤니티
- [ ] 영상
- [ ] 공유
- [ ] 이직 후 했던 일 구조화 및 정리 (성과, 배움 위주로)

그리고, 기술 관련 책은 아래 5권만을 정독할 예정.

- [ ] 코딩인터뷰 완전분석
- [ ] Clean Architecture
- [ ] HTTP 완벽가이드 (2/3 가량 읽었었고, 남은 1/3 읽을 예정)
- [ ] HTTP/2
- [ ] Mamangement 3.0

# 08/27

며칠 동안 틈틈히 리액터 파이프라인 성능 실험 추가로 진행. Flux#groupBy가 기존의 여러 방식들 중(대략 12가지 방식을 비교)에서 성능과 가독성 측면에서 가장 좋은 결과를 보임. 실무에도 적용.

결과 코드는 아래 링크 참고. 여기서는 backpressure, retry 등의 처리는 제외.

https://github.com/codehumane/reactor-performance-test/blob/master/src/main/kotlin/com/codehumane/reactor/performance/pipeline/advanced/GroupByAndGroupByPipeline.kt

# 08/28

HackerRank도 최근에 풀어보기 시작함.

- [x] [HackerRank, 2D Array - DS (Hourglass Sum)](https://github.com/codehumane/algorithm/blob/master/src/main/kotlin/hackerrank/HourglassSum.kt) 그리고 [테스트 케이스](https://github.com/codehumane/algorithm/blob/master/src/test/kotlin/hackerrank/HourglassSumTest.kt)
- [x] [HackerRank, Arrays: Left Rotation](https://github.com/codehumane/algorithm/blob/master/src/main/kotlin/hackerrank/LeftRotation.kt) 그리고 [테스트 케이스](https://github.com/codehumane/algorithm/blob/master/src/test/kotlin/hackerrank/LeftRotationTest.kt)

# 08/31

## HackerRank

- [x] [Minimum Swaps 2 n^2 버전 구현](https://github.com/codehumane/algorithm/blob/106c4c1e1135f166bcb8bb79c03823bd17bdb5e5/src/main/kotlin/hackerrank/MinimumSwaps2.kt)
- [x] [Minimum Swaps 2 약간의 성능 개선 구현](https://github.com/codehumane/algorithm/blob/master/src/main/kotlin/hackerrank/MinimumSwaps2.kt)
    - 중복되지 않은 연속적인 숫자가 배열에 들어있다는 점,
    - 그리고 그 숫자가 `배열의 인덱스 + 1`이라는 점,
    - 이 2가지를 이용하면 굳이 매 번 indexOf를 할 필요 없이,
    - 좀 더 효율적으로 swap 진행이 가능함.
    - 문제에 답이 있음.
- [Minimum Swaps 2에 대한 테스트 케이스](https://github.com/codehumane/algorithm/blob/master/src/test/kotlin/hackerrank/MinimumSwaps2KtTest.kt)