
# 07/05

## 계수 정렬(counting sort)

HackerRank의 [Fraudulent Activity Notifications](https://www.hackerrank.com/challenges/fraudulent-activity-notifications/problem) 문제의 성능 개선 풀이를 보니, 계수정렬(counting sort)이 나오길래 간단히 정리. 내용은 [Counting Sort Algorithm](https://www.programiz.com/dsa/counting-sort)을 보고 기록.

1. 일단, 주어진 배열에서 가장 큰 값을 찾는다.
2. 그리고 이 값을 `max`라고 하자.
3. `max + 1` 크기의 배열을 생성.
4. 이 때, 원소의 초기 값들은 0으로 지정.
5. 원소의 값을 배열의 인덱스로 하여, 각 원소의 발견 횟수를 배열에 저장. counting array가 된 것.
6. 마지막으로, 배열을 왼쪽에서부터 누적 합으로 치환.
7. 이제 원래 배열의 특정 원소 값이 몇 번째로 작은 값인지 구할 수 있다.
8. 배열 원소의 값을 인덱스로 하여 counting array의 값을 구하고 여기서 1을 빼면 됨.

[여기에 간단히 구현해 봄](https://github.com/codehumane/algorithm/commit/21c29ce2b777f30ec5e15bb717b0a1bf63915ca2). 아래 그림도 함께 참고.

![](https://cdn.programiz.com/sites/tutorial2program/files/Counting-sort-4_1.png)

## HackerRank

- [Sorting: Bubble Sort 풀이](https://github.com/codehumane/algorithm/commit/c7a2dd8192bb9aaeb61ea67dc8946bcfcc5f792b) 추가.
- 다음으로 [Fraudulent Activity Notifications의 N·log(d) 구현](https://github.com/codehumane/algorithm/commit/980c71f56ad42f5d478396e30aa7182b431afae1).
- 이를 [O(N·d) 혹은 O(N)으로의 개선](https://github.com/codehumane/algorithm/commit/9cc4c98238257352178a680df908037dc7e8ff29).
- 개선 버전은 [여기 풀이](https://fizzbuzzer.com/fraudulent-activity-notifications-challenge/)를 참고 했음.

# 07/06

## Min Stack

[Design and Implement Special Stack Data Structure | Added Space Optimized Version](https://www.geeksforgeeks.org/design-and-implement-special-stack-data-structure/)

> `push`, `pop`, `isEmpty`, `isFull` 연산과 더불어, 최소 엘리먼트를 반환하는 `getMin` 연산까지 지원하는 스택을 구현하라. 이 연산들은 모두 O(1)이어야 함. 구현 시에는 일반적인 스택 데이터 구조만 사용해야 함. 배열이나 리스트 등의 추가적인 데이터 구조체는 사용 X.

구현은 간단.

```kotlin
/**
 * 연산  | 스택        | 부가스택
 * push | 10         | 10
 * push | 10,20      | 10,10
 * push | 10,20,30   | 10,10,10
 * push | 10,20,30,5 | 10,10,10,5
 * pop  | 10,20,30   | 10,10,10
 */
class SpecialStack {

    private val original: Deque<Int> = ArrayDeque<Int>()
    private val minimum: Deque<Int> = ArrayDeque<Int>()

    fun push(element: Int) {
        original.push(element)
        minimum.push(determineMinimum(element))
    }

    private fun determineMinimum(element: Int): Int {
        if (minimum.isEmpty()) {
            return element
        }

        return min(
            minimum.peek(),
            element
        )
    }

    fun pop(): Int {
        minimum.pop()
        return original.pop()
    }

    fun min(): Int {
        return minimum.peek()
    }

}
```

# 07/07

## AMQP

- [Spring AMQP - Receiving Messages 정리](https://github.com/codehumane/what-i-learned/blob/master/document/spring-amqp-receiving-messages.md) 추가

# 07/12

## HackerRank

- [Merge Sort: Counting Inversions](https://www.hackerrank.com/challenges/ctci-merge-sort/problem?h_l=interview&playlist_slugs%5B%5D=interview-preparation-kit&playlist_slugs%5B%5D=sorting)
- [이름 자체가 병합정렬이라, 이를 이용하여 구현](https://github.com/codehumane/algorithm/commit/e5a9c5f93945b2b065c0423cb7c37bc9527d121d).
- 병합정렬과 크게 다를 바 없음.
- 병합정렬하면 아래와 같은 `21312` 회문순열 수가 떠오름.

```
       21312
       /   \
     213    12
     / \    / \
   21   3  1   2
  / \   |  |   |
 2   1  3  1   2
 \  /   |   \ /
  12    3   12
   \   /    |
    123     12
      \    /
      11223
```

# 07/14

## AMQP - Publisher Confirms

[Introducing Publisher Confirms](https://www.rabbitmq.com/blog/2011/02/10/introducing-publisher-confirms/)

- 메시지 유실을 막는 한 가지 방법.
- 전통적 방법으로는 트랜잭션이 있음.
- 하지만 이는 블럭킹.
- 그리고 매번 커밋할 때마다 무거운 `fsync()`가 호출. ([fsync](https://man7.org/linux/man-pages/man2/fsync.2.html))
- 결국, 너무 느림.
- 트랜잭션 사용하는 코드는 아래와 같음.

```java
Connection conn = connectionFactory.newConnection();
Channel ch = conn.createChannel();
ch.queueDeclare(QUEUE_NAME, true, false, true, null);
ch.txSelect();
for (int i = 0; i < MSG_COUNT; ++i) {
    ch.basicPublish(
        "",
        QUEUE_NAME,
        MessageProperties.PERSISTENT_BASIC,
        "nop".getBytes()
    );
    ch.txCommit();
}
ch.close();
conn.close();
```

- 채널을 confirm mode로 사용하면,
- 브로커가 메시지를 처리할 때 메시지에 대한 confirm을 수행.
- 이는 비동기. 브로커를 기다리지 않아도 됨.
- 또한, 브로커는 디스크 쓰기를 일괄로 처리(효과적)할 수 있음.
- [com.rabbitmq.client.impl.ChannelN](https://www.rabbitmq.com/releases/rabbitmq-java-client/v3.5.4/rabbitmq-java-client-javadoc-3.5.4/com/rabbitmq/client/impl/ChannelN.html)을 보면 코드를 확인할 수 있음.

```java
/** Set of currently unconfirmed messages (i.e. messages that have
    *  not been ack'd or nack'd by the server yet. */
private final SortedSet<Long> unconfirmedSet =
        Collections.synchronizedSortedSet(new TreeSet<Long>());

/** Public API - {@inheritDoc} */
@Override
public void basicPublish(String exchange, String routingKey,
                            boolean mandatory, boolean immediate,
                            BasicProperties props, byte[] body)
    throws IOException
{
    if (nextPublishSeqNo > 0) {
        unconfirmedSet.add(getNextPublishSeqNo());
        nextPublishSeqNo++;
    }
    // ...
}

private void handleAckNack(long seqNo, boolean multiple, boolean nack) {
    if (multiple) {
        unconfirmedSet.headSet(seqNo + 1).clear();
    } else {
        unconfirmedSet.remove(seqNo);
    }
    synchronized (unconfirmedSet) {
        onlyAcksReceived = onlyAcksReceived && !nack;
        if (unconfirmedSet.isEmpty())
            unconfirmedSet.notifyAll();
    }
}
```

- 내부 동작 설명도 잘 나와 있음.
- `confirm.select` 메서드를 통해 채널의 publisher confirm을 활성화.
- 활성화 되면 `confirm.select-ok` 응답.
- 이 때부터 퍼블리셔와 브로커는 퍼블리시에 대해 채번 시작.
- 그리고 퍼블리서는 `basic.ack` 메서드를 받음.
- 여기의 `delivery-tag` 필드가 confirmed message의 번호.
- 브로커가 메시지를 접수(acknowledges)하면 퍼블리셔에게 이를 알림.
- un-routable mandatory 또는 immediate 메시지는 `basic.return` 후 바로 confirmed.
- transient 메시지는 enqueued 시점에 confirmed.
- persistent 메시지는 디스크 영속이 되거나 모든 큐에 컨슘되면 confirmed.
- 아래의 몇 가지 주의점도 언급.

> There are some gotchas regarding confirms. Â Firstly, the broker makes no guarantees as to when a message will be confirmed, only that it will be confirmed. Â Secondly, message processing slows down as un-confirmed messages pile up: the broker does several O(log(number-of-unconfirmed-messages)) operations for each confirm-mode publish. Â Thirdly, if the connection between the publisher and broker drops with outstanding confirms, it does not necessarily mean that the messages were lost, so republishing may result in duplicate messages. Lastly, if something bad should happen inside the broker and cause it to lose messages, it will basic.nack those messages (hence, the handleNack() in ConfirmHandler).

https://www.rabbitmq.com/amqp-0-9-1-reference.html#basic.publish.mandatory

# 07/17

## Distributed locks with Redis

https://redis.io/topics/distlock

Redlock이라 불리는 알고리즘의 제안.

- 기존의 DLM (Distributed Lock Manager) 구현체들의 한계 때문.
- 서로 다른 접근법을 취하고, 쉬운 접근법으로 인해 다소 약한 보장을 하고 있음.

Redlock이 목표로 하는 보장.

1. Safety property
    - Mutual exclusion.
    - 한 번에 한 개의 클라이언트만 락을 소유.
2. Liveness property A
    - Deadlock free.
    - 결과적으로<sup>eventually</sup> 락의 획득은 언제나 가능.
    - 리소스를 잠근 클라이언트가 장애가 나거나 파티션 되더라도(split brain을 말하는 게 아닐까).
3. Liveness property B
    - Fault tolerance.
    - 대다수의 레디스 노드가 살아있기만 한다면, 클라이언트는 락을 획득하고 풀 수 있음.

페일오버 기반의 구현(대부분의 DLM 방식)이 왜 충분치 않은지.

```
// 잠금 획득
SET resource_name my_random_value NX PX 30000

// 잠금 해제
if redis.call("get",KEYS[1]) == ARGV[1] then
    return redis.call("del",KEYS[1])
else
    return 0
end
```

- 리소스 잠금을 위해 한 인스턴스에서 키를 생성.
- TTL도 함께 설정. 클라이언트에 문제가 있더라도 결국에는 락을 해제하기 위함. liveness property A.
- 리소스 잠금 해제 시에는 키를 삭제.
- SPOF가 되지 않기 위해 레디스 리더/팔로워(페일오버) 구성 필요.
- 하지만, 데이터 복제는 비동기로 이뤄짐.
- 복제가 이뤄지기 전에 리더가 죽으면, safety property 위반 가능.

Redlock 알고리즘은 아래와 같음.

1. 현재 시간을 구함.
2. N개의 인스턴스들에게 차례로 같은 키(그리고 랜덤 값으로)에 대한 락 획득 시도. 획득에 대한 타임아웃은 잠금의 자동 해제 시간보다 작아야 함. 레디스 노드가 장애인 상황에서 클라이언트가 블럭킹 된 상태로 오랫동안 남아 있는 것을 막아줌. 인스턴스가 이용 불가라면 빠르게 다음 인스턴스와의 대화 시도.
3. 클라이언트는 얼마나 많은 시간을 잠금 획득에 쏟았는지를 계산. 2번이 완료된 시간에서 1번에서 구한 시간을 빼면 됨. 과반수 이상으로부터 잠금을 획득했고, 획득 소요시간이 잠금 유효 시간보다 작다면, 락을 획득한 걸로 간주.
4. 잠금이 획득됐다면, 잠금 유효 시간은 초기의 유효 시간에서 획득 소요 시간을 뺀 값이 됨.
5. 만약 어떤 이유로든 잠금 획득에 실패했다면, 모든 인스턴스로부터 잠금 취소를 시도.
