
# 07/05

## 계수 정렬(counting sort)

HackerRank의 [Fraudulent Activity Notifications](https://www.hackerrank.com/challenges/fraudulent-activity-notifications/problem) 문제의 성능 개선 풀이를 보니, 계수정렬(counting sort)이 나오길래 간단히 정리. 내용은 [Counting Sort Algorithm](https://www.programiz.com/dsa/counting-sort)을 보고 기록.

1. 일단, 주어진 배열에서 가장 큰 값을 찾는다.
2. 그리고 이 값을 `max`라고 하자.
3. `max + 1` 크기의 배열을 생성.
4. 이 때, 원소의 초기 값들은 0으로 지정.
5. 원소의 값을 배열의 인덱스로 하여, 각 원소의 발견 횟수를 배열에 저장. counting array가 된 것.
6. 마지막으로, 배열을 왼쪽에서부터 누적 합으로 치환.
7. 이제 원래 배열의 특정 원소 값이 몇 번째로 작은 값인지 구할 수 있다.
8. 배열 원소의 값을 인덱스로 하여 counting array의 값을 구하고 여기서 1을 빼면 됨.

아래 그림 참고.

![](https://cdn.programiz.com/sites/tutorial2program/files/Counting-sort-4_1.png)

간단히 구현.

```java
public class CountingSort {

    public void sort(int[] array) {
        final int max = max(array);
        final int[] counting = new int[max + 1];
        final int[] result = new int[array.length];

        for (int element : array) {
            counting[element]++;
        }

        for (int i = 1; i < counting.length; i++) {
            counting[i] += counting[i - 1];
        }

//        for (int i = array.length - 1; i >= 0; i--) {
//            result[counting[array[i]] - 1] = array[i];
//            counting[array[i]]--;
//        }

        int index = 0;
        for (int i = 0; i < counting.length; i++) {
            int count = (i == 0) ? counting[i] : counting[i] - counting[i - 1];
            while (count > 0) {
                result[index++] = i;
                count--;
            }
        }

        System.arraycopy(result, 0, array, 0, result.length);
    }

    private int max(int[] array) {
        return Arrays
                .stream(array)
                .max()
                .orElse(0);
    }

}
```
