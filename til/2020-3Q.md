
# 07/05

## 계수 정렬(counting sort)

HackerRank의 [Fraudulent Activity Notifications](https://www.hackerrank.com/challenges/fraudulent-activity-notifications/problem) 문제의 성능 개선 풀이를 보니, 계수정렬(counting sort)이 나오길래 간단히 정리. 내용은 [Counting Sort Algorithm](https://www.programiz.com/dsa/counting-sort)을 보고 기록.

1. 일단, 주어진 배열에서 가장 큰 값을 찾는다.
2. 그리고 이 값을 `max`라고 하자.
3. `max + 1` 크기의 배열을 생성.
4. 이 때, 원소의 초기 값들은 0으로 지정.
5. 원소의 값을 배열의 인덱스로 하여, 각 원소의 발견 횟수를 배열에 저장. counting array가 된 것.
6. 마지막으로, 배열을 왼쪽에서부터 누적 합으로 치환.
7. 이제 원래 배열의 특정 원소 값이 몇 번째로 작은 값인지 구할 수 있다.
8. 배열 원소의 값을 인덱스로 하여 counting array의 값을 구하고 여기서 1을 빼면 됨.

[여기에 간단히 구현해 봄](https://github.com/codehumane/algorithm/commit/21c29ce2b777f30ec5e15bb717b0a1bf63915ca2). 아래 그림도 함께 참고.

![](https://cdn.programiz.com/sites/tutorial2program/files/Counting-sort-4_1.png)

## HackerRank

- [Sorting: Bubble Sort 풀이](https://github.com/codehumane/algorithm/commit/c7a2dd8192bb9aaeb61ea67dc8946bcfcc5f792b) 추가.
- 다음으로 [Fraudulent Activity Notifications의 N·log(d) 구현](https://github.com/codehumane/algorithm/commit/980c71f56ad42f5d478396e30aa7182b431afae1).
- 이를 [O(N·d) 혹은 O(N)으로의 개선](https://github.com/codehumane/algorithm/commit/9cc4c98238257352178a680df908037dc7e8ff29).
- 개선 버전은 [여기 풀이](https://fizzbuzzer.com/fraudulent-activity-notifications-challenge/)를 참고 했음.

# 07/06

## Min Stack

[Design and Implement Special Stack Data Structure | Added Space Optimized Version](https://www.geeksforgeeks.org/design-and-implement-special-stack-data-structure/)

> `push`, `pop`, `isEmpty`, `isFull` 연산과 더불어, 최소 엘리먼트를 반환하는 `getMin` 연산까지 지원하는 스택을 구현하라. 이 연산들은 모두 O(1)이어야 함. 구현 시에는 일반적인 스택 데이터 구조만 사용해야 함. 배열이나 리스트 등의 추가적인 데이터 구조체는 사용 X.

구현은 간단.

```kotlin
/**
 * 연산  | 스택        | 부가스택
 * push | 10         | 10
 * push | 10,20      | 10,10
 * push | 10,20,30   | 10,10,10
 * push | 10,20,30,5 | 10,10,10,5
 * pop  | 10,20,30   | 10,10,10
 */
class SpecialStack {

    private val original: Deque<Int> = ArrayDeque<Int>()
    private val minimum: Deque<Int> = ArrayDeque<Int>()

    fun push(element: Int) {
        original.push(element)
        minimum.push(determineMinimum(element))
    }

    private fun determineMinimum(element: Int): Int {
        if (minimum.isEmpty()) {
            return element
        }

        return min(
            minimum.peek(),
            element
        )
    }

    fun pop(): Int {
        minimum.pop()
        return original.pop()
    }

    fun min(): Int {
        return minimum.peek()
    }

}
```

# 07/07

## AMQP

- [Spring AMQP - Receiving Messages 정리](https://github.com/codehumane/what-i-learned/blob/master/document/spring-amqp-receiving-messages.md) 추가

# 07/12

## HackerRank

- [Merge Sort: Counting Inversions](https://www.hackerrank.com/challenges/ctci-merge-sort/problem?h_l=interview&playlist_slugs%5B%5D=interview-preparation-kit&playlist_slugs%5B%5D=sorting)
- [이름 자체가 병합정렬이라, 이를 이용하여 구현](https://github.com/codehumane/algorithm/commit/e5a9c5f93945b2b065c0423cb7c37bc9527d121d).
- 병합정렬과 크게 다를 바 없음.
- 병합정렬하면 아래와 같은 `21312` 회문순열 수가 떠오름.

```
       21312
       /   \
     213    12
     / \    / \
   21   3  1   2
  / \   |  |   |
 2   1  3  1   2
 \  /   |   \ /
  12    3   12
   \   /    |
    123     12
      \    /
      11223
```

# 07/14

## AMQP

[Introducing Publisher Confirms](https://www.rabbitmq.com/blog/2011/02/10/introducing-publisher-confirms/)

- 메시지 유실을 막는 한 가지 방법.
- 전통적 방법으로는 트랜잭션이 있음.
- 하지만 이는 블럭킹.
- 그리고 매번 커밋할 때마다 무거운 `fsync()`가 호출. ([fsync](https://man7.org/linux/man-pages/man2/fsync.2.html))
- 결국, 너무 느림.
- 트랜잭션 사용하는 코드는 아래와 같음.

```java
Connection conn = connectionFactory.newConnection();
Channel ch = conn.createChannel();
ch.queueDeclare(QUEUE_NAME, true, false, true, null);
ch.txSelect();
for (int i = 0; i < MSG_COUNT; ++i) {
    ch.basicPublish(
        "",
        QUEUE_NAME,
        MessageProperties.PERSISTENT_BASIC,
        "nop".getBytes()
    );
    ch.txCommit();
}
ch.close();
conn.close();
```

- 채널을 confirm mode로 사용하면,
- 브로커가 메시지를 처리할 때 메시지에 대한 confirm을 수행.
- 이는 비동기. 브로커를 기다리지 않아도 됨.
- 또한, 브로커는 디스크 쓰기를 일괄로 처리(효과적)할 수 있음.
- [com.rabbitmq.client.impl.ChannelN](https://www.rabbitmq.com/releases/rabbitmq-java-client/v3.5.4/rabbitmq-java-client-javadoc-3.5.4/com/rabbitmq/client/impl/ChannelN.html)을 보면 코드를 확인할 수 있음.

```java
/** Set of currently unconfirmed messages (i.e. messages that have
    *  not been ack'd or nack'd by the server yet. */
private final SortedSet<Long> unconfirmedSet =
        Collections.synchronizedSortedSet(new TreeSet<Long>());

/** Public API - {@inheritDoc} */
@Override
public void basicPublish(String exchange, String routingKey,
                            boolean mandatory, boolean immediate,
                            BasicProperties props, byte[] body)
    throws IOException
{
    if (nextPublishSeqNo > 0) {
        unconfirmedSet.add(getNextPublishSeqNo());
        nextPublishSeqNo++;
    }
    // ...
}

private void handleAckNack(long seqNo, boolean multiple, boolean nack) {
    if (multiple) {
        unconfirmedSet.headSet(seqNo + 1).clear();
    } else {
        unconfirmedSet.remove(seqNo);
    }
    synchronized (unconfirmedSet) {
        onlyAcksReceived = onlyAcksReceived && !nack;
        if (unconfirmedSet.isEmpty())
            unconfirmedSet.notifyAll();
    }
}
```

- 내부 동작 설명도 잘 나와 있음.
- `confirm.select` 메서드를 통해 채널의 publisher confirm을 활성화.
- 활성화 되면 `confirm.select-ok` 응답.
- 이 때부터 퍼블리셔와 브로커는 퍼블리시에 대해 채번 시작.
- 그리고 퍼블리서는 `basic.ack` 메서드를 받음.
- 여기의 `delivery-tag` 필드가 confirmed message의 번호.
- 브로커가 메시지를 접수(acknowledges)하면 퍼블리셔에게 이를 알림.
- un-routable mandatory 또는 immediate 메시지는 `basic.return` 후 바로 confirmed.
- transient 메시지는 enqueued 시점에 confirmed.
- persistent 메시지는 디스크 영속이 되거나 모든 큐에 컨슘되면 confirmed.
- 아래의 몇 가지 주의점도 언급.

> There are some gotchas regarding confirms. Â Firstly, the broker makes no guarantees as to when a message will be confirmed, only that it will be confirmed. Â Secondly, message processing slows down as un-confirmed messages pile up: the broker does several O(log(number-of-unconfirmed-messages)) operations for each confirm-mode publish. Â Thirdly, if the connection between the publisher and broker drops with outstanding confirms, it does not necessarily mean that the messages were lost, so republishing may result in duplicate messages. Lastly, if something bad should happen inside the broker and cause it to lose messages, it will basic.nack those messages (hence, the handleNack() in ConfirmHandler).

https://www.rabbitmq.com/amqp-0-9-1-reference.html#basic.publish.mandatory