
# 10/01

## Binary Tree Introduction

- 이번엔 [LeetCode의 Tree](https://leetcode.com/explore/learn/card/data-structure-tree/) 이야기.
- 트리의 각 노드는 루트 값과 다른 노드로의 참조 목록(자식 노드들이라고도 불림)을 가짐.
- 그래프 관점에서, 트리는 방향이 있는 비순환 그래프이며, N 개의 노드와 N-1 개의 엣지를 가짐.
- 바이너리 트리는 대표적인 트리 구조체.
- 이름에서 알 수 있듯, 각 노드는 최대 2개의 자식을 가짐.
- 왼쪽 자식 노드와 오른쪽 자식 노드.

## Traverse A Tree

- Pre-order Traversal(Root, Left, Right)
- In-order Traversal(Left, Root, Right)
- Post-order Traversal(Left, Right, Root)
- 아래와 같은 트리가 있을 때 각각의 순서.
- 1->2->4->5->3
- 4->2->5->1->3
- 4->5->2->3->1

```
    1
   / \
  2   3
 / \
4   5
```

- 일반적으로 이진 검색 트리에서 in-order 순회로 정렬된 데이터를 반환할 수 있음.
- 트리의 노드를 삭제할 때 post-order로 작업이 이뤄짐.
- post-order(스택을 함께 이용한)가 수학적 표현식에 많이 사용됨.
- [여기](https://www.geeksforgeeks.org/expression-tree/)에 나오는 아래 그림 참고.

![](https://media.geeksforgeeks.org/wp-content/uploads/expression-tree.png)

## 구현

- [일단 Pre Order Traversal 구현](https://github.com/codehumane/algorithm/commit/2b45c4135f912cd2e0bf1d24ccda7867f212d9ab).
- [Pre Order Traversal의 코드 간소화](https://github.com/codehumane/algorithm/commit/c1369c22137f3a629e28e212d1d9d381b5254761).
- [In Order Traversal 구현](https://github.com/codehumane/algorithm/commit/22856c955425e77a43779fbec375ee59571aac92).
- 마지막으로 [Post Order Traversal 구현](https://github.com/codehumane/algorithm/commit/b6fa476f10ddce43b0f78088fe498b0a3efb6d79).

# 10/02

## Level-order Traversal - Introduction

- 트리를 레벨 별로 순회하는 것.
- 예컨대 BFS.
- 아래 그림의 경우 순서는 1 -> 2 -> 3 -> 4 -> 5.
- 큐 사용이 구현에 도움이 됨.

```
    1
   / \
  2   3
 / \
4   5
```

- [간단히 구현까지 진행](https://github.com/codehumane/algorithm/commit/29e26f1da5d649da31a8c1429e771b40d6305278).
- 이 순회 특성상 일반적인 BFS와 다르게 큐는 없어도 되긴 함.

# 10/04

## Construct Binary Tree from Inorder and Postorder Traversal

- [LeetCode의 여기](https://leetcode.com/explore/learn/card/data-structure-tree/133/conclusion/942/) 내용.
- [구현은 여기](https://github.com/codehumane/algorithm/commit/4618c8353cea36c929aad27487dfd80041da8fb3).
- postorder의 마지막 값이 부모이고,
- inorder에서 부모를 찾아 반으로 나누는 것 까지는 생각했지만,
- postorder 인덱스를 하나씩 줄여갈 생각은 하지 못함.
- 결국 [여기 GeeksForGeeks 내용](https://www.geeksforgeeks.org/construct-a-binary-tree-from-postorder-and-inorder/)을 참고함.
- 구현 후 [2가지 개선](https://github.com/codehumane/algorithm/commit/57c49cea8627a4cefe56ff47e8f34e2bda4fb512).
- 먼저, 불필요한 `PostIndex` 클래스 제거하고 `AtomicInteger`로 대체.
- 그리고 parentIndex를 찾기 위해, 매번 inorder 배열 첫 번째 부터 탐색하는 대신, 필요한 범위만 탐색하도록 한정.

## Construct Binary Tree from Preorder and Inorder Traversal

- inorder와 postorder로부터 구하는 것과 유사하므로 바로 구현.
- [구현은 여기](https://github.com/codehumane/algorithm/commit/e28f7175405111497874162cb1e49f6c00411029).

# 10/05

## Populating Next Right Pointers in Each Node

- [LeetCode 문제는 여기](https://leetcode.com/explore/learn/card/data-structure-tree/133/conclusion/994/).
- [구현은 여기](https://github.com/codehumane/algorithm/commit/48cf308e9b0845063fe8dd89073a5e0a45c47fc3).

## Populating Next Right Pointers in Each Node II

- 위 문제와 너무나도 유사.
- 문제는 [여기](https://leetcode.com/explore/learn/card/data-structure-tree/133/conclusion/994/) 있고,
- 구현은 [여기](https://github.com/codehumane/algorithm/commit/af62d822ea068feb0d18593b7a04a46e63ec64aa)에.

# 10/06

## Lowest Common Ancestor of a Binary Tree

- 문제는 [여기](https://leetcode.com/explore/learn/card/data-structure-tree/133/conclusion/932/).
- [일단 생각나는 대로 풀어봄](https://github.com/codehumane/algorithm/commit/a5481152607b0628daf7b25955e82af1ae32b4b9).
