# 01/10

[ModelMapper](https://github.com/modelmapper/modelmapper)를 사용하는데 간헐적으로 엉뚱한 필드를 매핑하려는 오류를 만남. 오류 원인을 추적하고자 ModelMapper 안에 있는 [`TypeMapStore`](https://github.com/modelmapper/modelmapper/blob/master/core/src/main/java/org/modelmapper/internal/TypeMapStore.java)에서 `typeMaps` 필드 내용을 로그로 남김. 로그 내용을 보면 필드 매핑이 잘못되어 있음을 알게 됨. 예컨대, `Source` 클래스의 인스턴스를 `Destination` 타입으로 변환한다고 해보자. 두 클래스는 각각 `name`, `age`, `sex`, `phone` 속성을 가지고 있음. 이 때의 매핑 정보가 아래와 같은 식으로 되어 있는 것.

```
codehumane.Source -> codehumane.Destination
  PropertyMapping[Source.name -> Destination.name]
  PropertyMapping[Source.age -> Destination.age]
  PropertyMapping[Hello.hi -> Destination.sex] // Source.age 대신 엉뚱한 정보가 들어 있다.
  PropertyMapping[Source.phone -> Destination.phone]
```

그래서, source 클래스의 필드 정보를 어떻게 만드나 궁금해서 코드를 따라가 봄. 아래는 대략적인 코드의 호출 흐름.
1. `ImplicitMappingBuilder#new`
2. `TypeInfoImpl#getAccessors`
3. `PropertyInfoSetResolver.resolveAccessors`
4. `PropertyInfoResolver#propertyInfoFor`
5. `PropertyInfoRegistry.accessorFor`

이 중에서 문제가 된다고 생각하는 부분은 `PropertyInfoRegistry.accessorFor`. 코드를 보면 아래와 같음.

```java
// 중략 ...
private static final Map<Integer, Accessor> ACCESSOR_CACHE = new ConcurrentHashMap<Integer, Accessor>();

// 중략 ...
static synchronized Accessor accessorFor(Class<?> type,
                                         Method method,
                                         Configuration configuration,
                                         String name) {
    
  Integer hashCode = hashCodeFor(type, name, configuration);
  Accessor accessor = ACCESSOR_CACHE.get(hashCode);
  if (accessor == null) {
    accessor = new MethodAccessor(type, method, name);
    ACCESSOR_CACHE.put(hashCode, accessor);
  }

  return accessor;
}

// 중략 ...
private static Integer hashCodeFor(Class<?> initialType,
                                   String propertyName,
                                   Configuration configuration) {
    
  int result = 31 + initialType.hashCode();
  result = 31 * result + propertyName.hashCode();
  result = 31 * result + configuration.hashCode();
  return result;
}

// ...
```

`hashCodeFor`의 결과는 중복될 수 있음. 그래서 저 값을 키로 사용하면, 키가 중복될 경우 값이 덮어 씌워질 위험이 있음. 간단히 코드를 작성해 보면 이를 확인할 수 있음.

```java
@Test
public void hashCollision() {
    val key1 = new Key("aaa");
    val key2 = new Key("bbb");
    val key1HashCode = key1.hashCode();
    val key2HashCode = key2.hashCode();

    /*
     * hashCode 결과가 같은 Key 인스턴스를 키로 하여, 맵에 저장.
     * 해시 충돌 해결이 잘 되는 경우
     */
    val valid = new HashMap<Key, String>();
    valid.put(key1, "AAA");
    valid.put(key2, "BBB");
    assertEquals("AAA", valid.get(key1));
    assertEquals("BBB", valid.get(key2));

    /*
     * hashCode 결과를 키로 사용하는 경우.
     * 값은 다른데, hashCode 결과는 얼마든지 같을 수 있음.
     * 그런데도, 이걸 그대로 키로 사용하면 문제가 됨.
     */
    val invalid = new HashMap<Integer, String>();
    invalid.put(key1HashCode, "AAA");
    invalid.put(key2HashCode, "BBB");
    assertEquals("AAA", invalid.get(key1HashCode)); // 여기서 "BBB"가 반환됨
    assertEquals("BBB", invalid.get(key2HashCode));
}
```

`Integer`를 그대로 키로 쓰지 말고, 아래와 같이 하는 게 어땠을까.

```java
@Getter
@RequiredArgsConstructor
class PropertyKey {

    private final Class<?> initialType;
    private final String propertyName;
    private final Configuration configuration;

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        PropertyKey that = (PropertyKey) o;
        return Objects.equals(initialType, that.initialType) &&
                Objects.equals(propertyName, that.propertyName) &&
                Objects.equals(configuration, that.configuration);
    }

    @Override
    public int hashCode() {
        int result = 31 + initialType.hashCode();
        result = 31 * result + propertyName.hashCode();
        result = 31 * result + configuration.hashCode();
        return result;
    }
}

class PropertyInfoRegistry {

    // 중략 ...
    private static final Map<PropertyKey, Accessor> ACCESSOR_CACHE = new ConcurrentHashMap<>();

    // 중략 ...
    static synchronized Accessor accessorFor(Class<?> type,
                                             Method method,
                                             Configuration configuration,
                                             String name) {
                                             
        final PropertyKey key = new PropertyKey(type, name, configuration);
        Accessor accessor = ACCESSOR_CACHE.get(key);
        if (accessor == null) {
            accessor = new MethodAccessor(type, method, name);
            ACCESSOR_CACHE.put(key, accessor);
        }

        return accessor;
    }

    // 중략 ...
}
```

아래는 해시 충돌에 관한 [Java API(Hashtable) 문서](https://docs.oracle.com/javase/10/docs/api/java/util/Hashtable.html)의 일부 설명.

> in the case of a "hash collision", a single bucket stores multiple entries, which must be searched sequentially

그리고 `HashMap#get`을 열어 보면 어떻게 동작하는지 어느 정도 알 수 있음.

```java
public V get(Object key) {
    Node<K,V> e;
    return (e = getNode(hash(key), key)) == null ? null : e.value;
}

final Node<K,V> getNode(int hash, Object key) {
    Node<K,V>[] tab; Node<K,V> first, e; int n; K k;
    if ((tab = table) != null && (n = tab.length) > 0 &&
            (first = tab[(n - 1) & hash]) != null) {
        if (first.hash == hash && // always check first node
                ((k = first.key) == key || (key != null && key.equals(k))))
            return first;
        if ((e = first.next) != null) {
            if (first instanceof TreeNode)
                return ((TreeNode<K,V>)first).getTreeNode(hash, key);
            do {
                if (e.hash == hash &&
                        ((k = e.key) == key || (key != null && key.equals(k))))
                    return e;
            } while ((e = e.next) != null);
        }
    }
    return null;
}
```

# 01/12

1. 01/10 내용 관련해서 [블로그 글도 추가](http://codehumane.github.io/2019/01/11/ModelMapper-HashCode-Collision/)하고,
2. [간단한 테스트 코드와 함께 PR도 제출함](https://github.com/modelmapper/modelmapper/pull/438).
3. 잘 돼서, 서비스 운영의 번거로움을 덜 수 있기를.

# 01/20

[ModelMapper 버그 수정 PR](https://github.com/modelmapper/modelmapper/pull/438)이 머지됨 :)

# 01/26

[Spring Data Redis](https://docs.spring.io/spring-data/redis/docs/2.1.4.RELEASE/reference/html/#redis.repositories)의 [@RedisHash](https://docs.spring.io/spring-data/redis/docs/current/api/org/springframework/data/redis/core/RedisHash.html)를 사용하는데, 여기서의 [timeToLive](https://docs.spring.io/spring-data/redis/docs/current/api/org/springframework/data/redis/core/RedisHash.html#timeToLive--) 설정이 제대로 먹지 않는 문제를 겪음. 예컨대, 아래의 데이터 구조가 있다고 해보자.

```java
@Value
@RedisHash(value = "BookRepresentation:v1", timeToLive = 15)
public class BookRepresentation {
    
    @Id
    private final String isbn;
    private final String title;
    // ...
}
```

이 데이터가 캐시된 뒤, [redis-cli](https://redis.io/topics/rediscli)를 통해 데이터를 확인해 보면 아래와 같음.

```shell
127.0.0.1:6379> keys *
1) "BookRepresentation:v1"
2) "BookRepresentation:v1:9788992825764:phantom"
3) "BookRepresentation:v1:9788992825764"
```

여기서 각 키의 의미는 아래와 같음.

1. `BookRepresentation:v1:9788992825764`: 캐싱 대상 그 자체
2. `BookRepresentation:v1:9788992825764:phantom`: 캐싱 데이터의 복제본
3. `BookRepresentation:v1`: 캐시된 데이터의 키 집합

ttl을 15초로 설정해 두었으니, 15초가 지난 뒤 캐시 데이터를 살펴봄.

```shell
127.0.0.1:6379> keys *
1) "BookRepresentation:v1"

127.0.0.1:6379> smembers BookRepresentation:v1
1) "9788992825764"
```

기대와 다르게 `BookRepresentation:v1`의 값이 지워지지 않음. 계속 쌓이기만 함. 여러가지 문제가 예상됨(ㅠㅠ). 왜 그런가를 찾아보고자 `KeyExpirationEventMessageListener`를 시작점으로 간단히 코드를 따라가 봄. 문제의 지점은 `RedisKeyValueAdapter#onMessage`의 [783L](https://github.com/spring-projects/spring-data-redis/blob/master/src/main/java/org/springframework/data/redis/core/RedisKeyValueAdapter.java#L783).

```java
RedisKeyExpiredEvent event = new RedisKeyExpiredEvent(channel, key, value);

ops.execute((RedisCallback<Void>) connection -> {
    connection.sRem(converter.getConversionService().convert(event.getKeyspace(), byte[].class), event.getId());
    new IndexWriter(connection, converter).removeKeyFromIndexes(event.getKeyspace(), event.getId());
    return null;
});

publishEvent(event);
```

`RedisKeyExpiredEvent` 인스턴스를 생성한 뒤, 이로부터 아이디를 가져오고, `RedisSetCommands#rRem`에 인자로 넘겨주고 있음. 참고로, `rRem`은 레디스의 집합 데이터에서 주어진 키에 대응하는 엘리먼트를 제거하는 것. 그런데, 여기서의 아이디가 `BookRepresentation:v1`이 아니고, `BookRepresentation`임. 잘못된 키이기 때문에 제거도 제대로 되지 않음.

왜 이렇게 예상과 다른 키를 반환하는지는 `BinaryKeyspaceIdentifier#extractId`를 보면 이유를 알 수 있음.

```java
/**
* Parse a binary {@code key} into {@link BinaryKeyspaceIdentifier}.
*
* @param key the binary key representation.
* @return {@link BinaryKeyspaceIdentifier} for binary key.
*/
public static BinaryKeyspaceIdentifier of(byte[] key) {

    Assert.isTrue(isValid(key), String.format("Invalid key %s", new String(key)));

    boolean phantomKey = ByteUtils.startsWith(key, PHANTOM_SUFFIX, key.length - PHANTOM_SUFFIX.length);

    int keyspaceEndIndex = ByteUtils.indexOf(key, DELIMITTER);
    byte[] keyspace = extractKeyspace(key, keyspaceEndIndex);
    byte[] id = extractId(key, phantomKey, keyspaceEndIndex);

    return new BinaryKeyspaceIdentifier(keyspace, id, phantomKey);
}
```

`DELIMITER` 값이 `:`이고, 첫 번째 `:`를 기준으로 keyspace와 id를 나누고 있음. [An introduction to Redis data types and abstractions](https://redis.io/topics/data-types-intro) 문서의 [Redis Key](https://redis.io/topics/data-types-intro#redis-keys) 부분을 보니, 일종의 관례(명시적이지는 않다)인 것 같다.

> Try to stick with a schema. For instance "object-type:id" is a good idea, as in "user:1000". Dots or dashes are often used for multi-word fields, as in "comment:1234:reply.to" or "comment:1234:reply-to".

스프링은 이걸 기반으로 아이디를 쪼갠 것 같고. 그래서, 이 문제를 회피하고자 한다면, KeySpace를 기존의 `BookRepresentation:v1` 대신, `BookRepresentation-v1` 같은 형태로 바꿔주기만 하면 됨. 아래와 같이 말이다.

```java
@Value
@RedisHash(value = "BookRepresentation-v1", timeToLive = 15)
public class BookRepresentation {
    
    @Id
    private final String isbn;
    private final String title;
    // ...
}
```

`@RedisHash`의 keySpace 설정부분에 약간의 설명을 달아줬으면 어땠을까 하는 아쉬움.

# 01/27

어제의 내용을 좀 더 다듬어서 [블로그에도 기록](http://codehumane.github.io/2019/01/26/RedisHash-timeToLive/).

