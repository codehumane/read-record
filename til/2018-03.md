# 03/01

## Codility

-  최근 재미 들린 퀴즈 풀이를 오늘도 진행.
-  [Nesting](https://app.codility.com/programmers/lessons/7-stacks_and_queues/nesting/)의 [O(N)/O(1) 구현](https://github.com/codehumane/learn-algorithm-in-java/commit/46476dac4de9ab33c4591cfe6588f5b7b57b6628). 공간 복잡도를 O(1)로 제한하고 있음에도 [Brackets](https://github.com/codehumane/learn-algorithm-in-java/commit/c2927107855fd9cbdc7dbe3023ad8bfa3fa01895)에 비해 많이 쉬움.
-  [StoneWall](https://app.codility.com/programmers/lessons/7-stacks_and_queues/stone_wall/)의 [O(N)/O(N) 구현](https://github.com/codehumane/learn-algorithm-in-java/commit/92c6eaed027de102f7d35c5af739bc479d5fe812). 문제 이해하는 데 시간이 오래 걸림. 하지만 이해하고 나면 풀이는 간단.
-  그런데 불현듯 궁금. 병합 정렬이나 스택, 큐 등을 이렇게 매번 직접 구현해야 하나?
-  기본적이고 자주 사용되는 것들은 암기가 되버림. 암기력 외에 어떤 의미가 있을지.


## SRE

-  [사이트 신뢰성 엔지니어링](https://github.com/codehumane/what-i-learned/blob/master/sre/README.md) 책을 읽기 시작. 재밌다.

# 03/03

## Codility

-  [Dominator](https://app.codility.com/programmers/lessons/8-leader/dominator/) 퀴즈 풀이 진행.
-  [O(N*log(N)) 시간 복잡도와 O(N) 공간 복잡도 구현](https://github.com/codehumane/learn-algorithm-in-java/commit/e3bf31d86a953a950deedd5e243d694f31a88593)
-  중위수가 가장 큰 수이거나 가장 작은 수이면 그 수가 바로 과반수 이상을 차지하는 수임. 정렬하면 쉽게 파악 가능.
-  하지만 퀴즈에서 원하는 시간 복잡도와 공간 복잡도는 각각 O(N)과 O(1)이었음.
-  [Boyer-Moore majority vote algorithm](https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm)을 참고하여 작성.
-  아이디어만 알면 구현은 간단. 코드는 [여기 기록](https://github.com/codehumane/learn-algorithm-in-java/commit/709b11485263e4987b27ca1c4e0d094e97480a43).

