# 03/01

## Codility

-  최근 재미 들린 퀴즈 풀이를 오늘도 진행.
-  [Nesting](https://app.codility.com/programmers/lessons/7-stacks_and_queues/nesting/)의 [O(N)/O(1) 구현](https://github.com/codehumane/learn-algorithm-in-java/commit/46476dac4de9ab33c4591cfe6588f5b7b57b6628). 공간 복잡도를 O(1)로 제한하고 있음에도 [Brackets](https://github.com/codehumane/learn-algorithm-in-java/commit/c2927107855fd9cbdc7dbe3023ad8bfa3fa01895)에 비해 많이 쉬움.
-  [StoneWall](https://app.codility.com/programmers/lessons/7-stacks_and_queues/stone_wall/)의 [O(N)/O(N) 구현](https://github.com/codehumane/learn-algorithm-in-java/commit/92c6eaed027de102f7d35c5af739bc479d5fe812). 문제 이해하는 데 시간이 오래 걸림. 하지만 이해하고 나면 풀이는 간단.
-  그런데 불현듯 궁금. 병합 정렬이나 스택, 큐 등을 이렇게 매번 직접 구현해야 하나?
-  기본적이고 자주 사용되는 것들은 암기가 되버림. 암기력 외에 어떤 의미가 있을지.


## SRE

-  [사이트 신뢰성 엔지니어링](https://github.com/codehumane/what-i-learned/blob/master/sre/README.md) 책을 읽기 시작. 재밌다.

# 03/03

## Codility

-  [Dominator](https://app.codility.com/programmers/lessons/8-leader/dominator/) 퀴즈 풀이 진행.
-  [O(N*log(N)) 시간 복잡도와 O(N) 공간 복잡도 구현](https://github.com/codehumane/learn-algorithm-in-java/commit/e3bf31d86a953a950deedd5e243d694f31a88593).
-  중위수가 가장 큰 수이거나 가장 작은 수이면 그 수가 바로 과반수 이상을 차지하는 수임. 정렬하면 쉽게 파악 가능.
-  하지만 퀴즈에서 원하는 시간 복잡도와 공간 복잡도는 각각 O(N)과 O(1)이었음.
-  [Boyer-Moore majority vote algorithm](https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm)을 참고하여 작성.
-  아이디어만 알면 구현은 간단. 코드는 [여기 기록](https://github.com/codehumane/learn-algorithm-in-java/commit/709b11485263e4987b27ca1c4e0d094e97480a43).

# 03/04

## Codility

### EquiLeader

-  [EquiLeader](https://app.codility.com/programmers/lessons/8-leader/equi_leader/)의 [O(N) 시간 복잡도와 O(1) 공간 복잡도 구현](https://github.com/codehumane/learn-algorithm-in-java/commit/434eea014180844dcc519c0b22f3f0db17d742db).
-  양분된 배열 각각에 리더가 존재한다면, 원래의 배열에도 리더가 존재함.
-  다만, 역은 성립치 않음에 주의. 예를 들면, `[1, 2, 2]` 같은 것.
-  따라서, 리더를 먼저 구한 뒤 약간만 주의해서 `EquiLeader`를 찾으면 됨.
-  이러한 의도를 가능한 코드로 드러내려고 노력함. 하지만 장황해 보이기도.
-  [Dominator](https://github.com/codehumane/learn-algorithm-in-java/blob/master/src/main/java/quiz/Dominator.java)를 먼저 구현해 봤기 때문에 쉽게 떠올릴 수 있었던 아이디어라 생각함.

### CountDiv

-  더불어, [CountDiv](https://app.codility.com/programmers/lessons/5-prefix_sums/count_div/) 문제도 [O(1) 시간 복잡도, O(1) 공간 복잡도로 구현](https://github.com/codehumane/learn-algorithm-in-java/commit/043040b5cce7ebbc64eafaa50d19fbce6bbb65b4).
-  주어진 범위를 제수(divisor)로 나누면 몫이 0인 피제수(dividend)의 개수를 알 수 있었음.
-  다만, 문제 풀이를 쉽게 하기 위해, 주어진 범위 중 몫이 0인 가장 작은 피제수를 찾은 뒤 시작.
-  다른 풀이들을 찾아보니 대부분 [Prefix sum](https://en.wikipedia.org/wiki/Prefix_sum) 방식. 이 개념을 모른다고 하더라도, 훨씬 직관적이고 쉽다.

### PassingCars

-  [PassingCars](https://app.codility.com/programmers/lessons/5-prefix_sums/passing_cars/)의 [O(N) 시간 복잡도, O(1) 공간 복잡도 구현](https://github.com/codehumane/learn-algorithm-in-java/commit/5b0163248de01b833658d3fca9b30fac3855de24).
-  배열을 순회하면서 현재 엘리먼트와 방향이 반대인 엘리먼트를 카운팅.
-  단, 이전 인덱스의 엘리먼트에 대해서만 찾으면 됨.
-  매번 새로 찾을 필요 없이, 배열 순회하면서 카운팅 해두면 됨.

## SRE

-  [SRE 관점에서 바라본 구글의 프로덕션 환경](https://github.com/codehumane/what-i-learned/blob/master/sre/README.md#sre-%EA%B4%80%EC%A0%90%EC%97%90%EC%84%9C-%EB%B0%94%EB%9D%BC%EB%B3%B8-%EA%B5%AC%EA%B8%80%EC%9D%98-%ED%94%84%EB%A1%9C%EB%8D%95%EC%85%98-%ED%99%98%EA%B2%BD)