# 10/04

## Desiging Data-Intensive Applications

### [Leaderless Replication](https://github.com/codehumane/what-i-learned/blob/master/book/ddia/Distributed-Data.md#leaderless-replication)

- [Writing to the Database When a Node is Down](https://github.com/codehumane/what-i-learned/blob/master/book/ddia/Distributed-Data.md#writing-to-the-database-when-a-node-is-down)
- [Limitations of Quorum Consistency](https://github.com/codehumane/what-i-learned/blob/master/book/ddia/Distributed-Data.md#limitations-of-quorum-consistency)
- [Sloppy Quorums and Hinted Handoff](https://github.com/codehumane/what-i-learned/blob/master/book/ddia/Distributed-Data.md#sloppy-quorums-and-hinted-handoff)

# 10/06

## Designing Data-Intensive Applications

- [Detecting Concurrent Writes](https://github.com/codehumane/what-i-learned/blob/master/book/ddia/Distributed-Data.md#detecting-concurrent-writes) 추가.
- 드디어 [Replication](https://github.com/codehumane/what-i-learned/blob/master/book/ddia/Distributed-Data.md#replication) 챕터 정리 끝.
- 생각 보다 모르는 것들이 너무 많았음. 무지의 무지.
- 전체적으로 한 번 정리할 필요가 있음. 요약 본으로 블로그에 올리자.

# 10/07

## Codility

- 정말 오랜만에.
- [Flags 문제](https://app.codility.com/programmers/lessons/10-prime_and_composite_numbers/flags/)를 [바보 단계로 먼저 풀어봄](https://github.com/codehumane/learn-algorithm-in-java/commit/9e149d7ea88ecee692f824663d8e0830270fa166).
- 조만간 개선.

## 알고리즘 도감

- 아주 가벼운 책. 개념 훑기에 좋음.
- [데이터 구조](https://github.com/codehumane/what-i-learned/blob/master/book/algorithms-explained-animated/README.md#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B5%AC%EC%A1%B0) 먼저 정리.
- [리스트](https://github.com/codehumane/what-i-learned/blob/master/book/algorithms-explained-animated/README.md#%EB%A6%AC%EC%8A%A4%ED%8A%B8), [배열](https://github.com/codehumane/what-i-learned/blob/master/book/algorithms-explained-animated/README.md#%EB%B0%B0%EC%97%B4), [스택](https://github.com/codehumane/what-i-learned/blob/master/book/algorithms-explained-animated/README.md#%EC%8A%A4%ED%83%9D), [큐](https://github.com/codehumane/what-i-learned/blob/master/book/algorithms-explained-animated/README.md#%ED%81%90), [해시 테이블](https://github.com/codehumane/what-i-learned/blob/master/book/algorithms-explained-animated/README.md#%ED%95%B4%EC%8B%9C-%ED%85%8C%EC%9D%B4%EB%B8%94), [힙](https://github.com/codehumane/what-i-learned/blob/master/book/algorithms-explained-animated/README.md#%ED%9E%99), [이진 탐색 트리](https://github.com/codehumane/what-i-learned/blob/master/book/algorithms-explained-animated/README.md#%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89-%ED%8A%B8%EB%A6%AC).

# 10/08

## Desiging Data-Intensive Applications

### [Partitioning](https://github.com/codehumane/what-i-learned/blob/master/book/ddia/Distributed-Data.md#partitioning)

- [Partitioning and Replication](https://github.com/codehumane/what-i-learned/blob/master/book/ddia/Distributed-Data.md#partitioning-and-replication)
- 파티셔닝도 기대됨. 어서 읽어 보고 싶음.

# 10/09

## Codility

- 이전에 [바보 단계로 먼저 풀었던 Flags](https://github.com/codehumane/learn-algorithm-in-java/commit/9e149d7ea88ecee692f824663d8e0830270fa166)를 O(N * log N)으로 [개선](https://github.com/codehumane/learn-algorithm-in-java/commit/b3aa8d53e8c49ae4c51d6bb5926b78fdfa1a040d).

# 10/11

## Designing Data-Intensive Applications

### [Partitioning of Key-Value Data](https://github.com/codehumane/what-i-learned/blob/master/book/ddia/Distributed-Data.md#partitioning-of-key-value-data)

- [Partitioning by Key Range](https://github.com/codehumane/what-i-learned/blob/master/book/ddia/Distributed-Data.md#partitioning-by-key-range)
- [Partitioning by Hash of Key](https://github.com/codehumane/what-i-learned/blob/master/book/ddia/Distributed-Data.md#partitioning-by-hash-of-key)
- [Skewed Workloads and Relieving Hot Spots](https://github.com/codehumane/what-i-learned/blob/master/book/ddia/Distributed-Data.md#skewed-workloads-and-relieving-hot-spots)

### [Partitioning and Secondary Indexes](https://github.com/codehumane/what-i-learned/blob/master/book/ddia/Distributed-Data.md#partitioning-of-key-value-data)

- [Partitioning Secondary Indexes by Document](https://github.com/codehumane/what-i-learned/blob/master/book/ddia/Distributed-Data.md#partitioning-secondary-indexes-by-document)
- [Partitioning Secondary Indexes by Term](https://github.com/codehumane/what-i-learned/blob/master/book/ddia/Distributed-Data.md#partitioning-secondary-indexes-by-term)

# 10/13

## Designing Data-Intensive Applications

### [Rebalancing Partitions](https://github.com/codehumane/what-i-learned/blob/master/book/ddia/Distributed-Data.md#rebalancing-partitions)

- [Strategies for Rebalancing](https://github.com/codehumane/what-i-learned/blob/master/book/ddia/Distributed-Data.md#strategies-for-rebalancing)
- [Operations: Automatic or Manual Rebalancing](https://github.com/codehumane/what-i-learned/blob/master/book/ddia/Distributed-Data.md#operations-automatic-or-manual-rebalancing)

### [Request Routing](https://github.com/codehumane/what-i-learned/blob/master/book/ddia/Distributed-Data.md#request-routing)

이것으로 파티셔닝 정리도 끝. 7장에서는 Isolation Level 등은 건너 뛰고, 좀 덜 익숙한 Serializability를 보자. 8장과 9장은 전체를 다 보는 걸로. 물론, 쉽지는 않을 거야..
# 10/15

- [spi](https://en.wikipedia.org/wiki/Service_provider_interface)가 뭔지 몰랐음. [org.hibernate.engine.jdbc.env.spi](https://docs.jboss.org/hibernate/orm/5.3/javadocs/org/hibernate/engine/jdbc/spi/package-summary.html#package.description)도 함께 참고. [여기](https://stackoverflow.com/a/2956803)에 따르면, [java.sql.Driver](https://docs.oracle.com/javase/6/docs/api/java/sql/Driver.html)도 일종의 spi.
- Designing Data-Intensive Application의 Replication 부분을 따로 [블로그로 정리](http://codehumane.github.io/2018/10/12/Designing-Data-Intensive-Application/). 약간의 재구성과 내용 요약하여 기록함.

# 10/21

1. [Designing Data-Intensive Application](https://www.amazon.com/Designing-Data-Intensive-Applications-Reliable-Maintainable/dp/1449373321)에서 Partitioning 부분을 [블로그에 정리](http://codehumane.github.io/2018/10/19/Designing-Data-Intensive-Application-Partitioning/)
2. 이런 저런 기술 확인을 해보고 싶어서, [간단한 책 검색 서비스](https://github.com/codehumane/book-service)를 만듦.

# 10/23

1. [Spring Data Redis 레퍼런스](https://docs.spring.io/spring-data/data-redis/docs/current/reference/html/) 문서를 살펴봄. 구축되어 있는 것을 활용하는 것 자체는 어렵지 않아 보임.
2. 또한, Redis의 내부 동작 원리도 파악하고자 [Redis Cluster Tutorial](https://redis.io/topics/cluster-tutorial)도 함께 살펴봄.
3. [Apache Ignite](https://apacheignite.readme.io/docs)에 대해서도 간단히 살펴봄.
4. [Off Heap Memory Usage](https://dzone.com/articles/heap-vs-heap-memory-usage)라는 게 있다는 것도 알게됨. 신기. 가비지 컬렉션은 없지만, 비워주지 않으면 결국 OOM.

# 11/04

1. [알고리즘 도감](https://github.com/codehumane/what-i-learned/blob/master/book/algorithms-explained-animated/README.md), [정렬](https://github.com/codehumane/what-i-learned/blob/master/book/algorithms-explained-animated/README.md#%EC%A0%95%EB%A0%AC)
2. [ClientAbortException](https://tomcat.apache.org/tomcat-8.0-doc/api/org/apache/catalina/connector/ClientAbortException.html)에 대한 설명이 [여기](https://confluence.atlassian.com/jirakb/clientabortexception-because-of-closing-a-page-before-it-finished-loading-225122378.html)에 간단하게 잘 나와 있음.

# 11/05

## [Redis Cluster tutorial](https://github.com/codehumane/what-i-learned/blob/master/document/redis-cluster-tutorial.md#redis-cluster-tutorial)

1. [Redis Cluster master-slave model](https://github.com/codehumane/what-i-learned/blob/master/document/redis-cluster-tutorial.md#redis-cluster-master-slave-model)
2. [Redis Cluster consistency guarantees](https://github.com/codehumane/what-i-learned/blob/master/document/redis-cluster-tutorial.md#redis-cluster-consistency-guarantees)

# 11/06

[Redis Cluster configuration parameters](https://github.com/codehumane/what-i-learned/blob/master/document/redis-cluster-tutorial.md#redis-cluster-configuration-parameters)

# 11/10

## [Redis Cluster Specification](https://github.com/codehumane/what-i-learned/blob/master/document/redis-cluster-specification.md)

[Main properties and rationales of the design](https://github.com/codehumane/what-i-learned/blob/master/document/redis-cluster-specification.md#main-properties-ans-rationales-of-the-design)

- [Redis Cluster goals](https://github.com/codehumane/what-i-learned/blob/master/document/redis-cluster-specification.md#redis-cluster-goals)
- [Implemented subset](https://github.com/codehumane/what-i-learned/blob/master/document/redis-cluster-specification.md#implemented-subset)
- [Clients and Servers roles in the Redis Cluster protocol](https://github.com/codehumane/what-i-learned/blob/master/document/redis-cluster-specification.md#clients-and-servers-roles-in-the-redis-cluster-protocol)
- [Write safety](https://github.com/codehumane/what-i-learned/blob/master/document/redis-cluster-specification.md#write-safety)
- [Availability](https://github.com/codehumane/what-i-learned/blob/master/document/redis-cluster-specification.md#availability)
- [Performance](https://github.com/codehumane/what-i-learned/blob/master/document/redis-cluster-specification.md#performance)
- [Why merge operations are avoided](https://github.com/codehumane/what-i-learned/blob/master/document/redis-cluster-specification.md#why-merge-operations-are-avoided)

# 11/11

## [Redis Cluster Specification](https://github.com/codehumane/what-i-learned/blob/master/document/redis-cluster-specification.md)

[Overview of Redis Cluster main components](https://github.com/codehumane/what-i-learned/blob/master/document/redis-cluster-specification.md#overview-of-redis-cluster-main-components)

- [Keys distribution model](https://github.com/codehumane/what-i-learned/blob/master/document/redis-cluster-specification.md#keys-distribution-model)
- [Keys hash tags](https://github.com/codehumane/what-i-learned/blob/master/document/redis-cluster-specification.md#keys-hash-tags)
- [Cluster nodes attributes](https://github.com/codehumane/what-i-learned/blob/master/document/redis-cluster-specification.md#cluster-nodes-attributes)
- [The Cluster bus](https://github.com/codehumane/what-i-learned/blob/master/document/redis-cluster-specification.md#the-cluster-bus)
- [Cluster topology](https://github.com/codehumane/what-i-learned/blob/master/document/redis-cluster-specification.md#cluster-topology)
- [Nodes handshake](https://github.com/codehumane/what-i-learned/blob/master/document/redis-cluster-specification.md#nodes-handshake)

## 그 외

1. [gossip protocol](https://1ambda.github.io/cloud-computing/cloud-computing-2/)
2. [프로덕트 스펙 문서 작성법](https://brunch.co.kr/@hj-kang/2) 뻔한 내용 같지만 참 잘 읽었고 공감함.

# 11/12

1. [Release It 2nd Edition](https://github.com/codehumane/what-i-learned/blob/master/book/release-it-2e/README.md) 정리 시작
2. 문장이 좀 어렵다. 어느 정도 지나서도 어렵다면 그냥 한글 책을 읽는 걸로.

# 11/13

Redis Cluster Specification, [MOVED Redirection](https://github.com/codehumane/what-i-learned/blob/master/document/redis-cluster-specification.md#moved-redirection)

# 11/14

1. Release It 2E, [Case Study: The Exception That Grounded an Airline](https://github.com/codehumane/what-i-learned/tree/master/book/release-it-2e#case-study-the-exception-that-grounded-an-airline)
2. [네이버 메인 페이지의 트래픽 처리](https://d2.naver.com/helloworld/6070967)

# 11/17

## 점수의 문제<sup>Problem of Points</sup>

A와 B라는 참가자가 각각 만원을 판돈으로 걸고 동전 게임을 시작. 앞면이 나오면 A가 1점을, 뒷면이 나오면 B가 1점을 가져감. 그리고 목표 점수에 먼저 다다르는 사람이 모든 판돈을 가져감. 만약, A가 5점, B가 3점을 획득한 상태에서, 지진 등의 이유로 게임이 중단되면 판돈을 어떻게 나눠야 할까?

1. A가 이기고 있었으니 A가 모든 판돈을 가져가는 것이 좋을까?
2. 그렇게 따지면 1:0인 상황에서도 A가 가져가는 게 맞을까? 이제 막 시작했을 뿐인데?
3. (루카 파치올리가 제시한 답) 판돈을 5:3으로 나누는 건 어떨까?
4. (16세기 중반 니콜로 타르탈리아라는 수학자의 비판) 만약, 목표 점수가 500점인데, 499:300인 경우에도 비율대로 나눠야 할까? 1점만 더 내면 모든 판돈을 가져갈 수 있는 상황인데도?

17세기에 이르러 페르마와 파스칼이 편지를 주고 받으며 이 문제에 대해 고심했다고 함. 내용의 핵심은 확률. 지금까지 딴 점수가 문제가 아니라, 미래에 대해 생각을 하고, 각자가 이길 확률을 계산하 것. 목표 점수가 7점이고 현재 점수가 5:3이면, B가 이길 수 있는 확률은 6/2^5가 됨. 따라서, A가 이길 확률은 1 - 3/16. 이 값에 따라 판돈을 나누면, A는 16,250원을, B는 3,750원을 받아야 함. 이를 현대적(?)인 용어로 풀면 'A와 B가 각자 자기의 기댓값을 받아야 한다'라고 함. 경우의 수를 고려하는 방법론도, 그리고 기댓값이라는 개념도 이 파스칼과 페르마의 서신에서 처음 등장했다고 함.

# 11/22

## IntelliJ Tips & Tricks

- UI 관련 소소한
  - nyan plugin
  - use dark window headers
- psvm
- [Search Everywhere](https://www.jetbrains.com/help/idea/searching-everywhere.html)
  - 탭 기능이 추가됨. (Actions가 매번 밑에 있어서 불편했는데 좋다)
  - 그 중에서 Actions에 바로 접근하고 싶다면 `⌘^a`
    - 자주 사용하지 않는 리팩토링 액션이나, 깃 명령어(annotate, git compare, revert, push, ...) 등에 활용.
  - abbreviation 추가도 가능 (rv, an)
- Run Anything (Debug with `^`)
  - gradle clean build
  - application
  - 전체 패키지 테스트 (기존에는 `⌥f1`, 좌측 화살표 키, `⌘r`)
  - action으로 실행 중지도 가능
- [complete statement](https://www.jetbrains.com/help/idea/auto-completing-code.html#statements_completion)
  - `⌘^⏎` (클래스, 메서드, 조건문, case문, ...)
  - 그 외 smart completion, hippie completion
- [language injections](https://www.jetbrains.com/help/idea/using-language-injections.html)
  - " + `⌥⏎` 
  - json, html, sql 등의 문법 체크
  - <u>`⌥⏎` 한 번 더 입력하면 edit <language ID> fragment</u>!
  - language injection comment를 이용하면 highlighting도 가능.
- [acejump](https://github.com/acejump/AceJump#acejump) plugin
  - vim 모드에서 부러운 것 중에 하나는 특정 단어로 바로 가기
  - `⌃;` 단어 찾아가기
  - `⌃⇧;` 라인 찾아가기
- [inserting a live template](https://www.jetbrains.com/help/idea/2017.3/creating-code-constructs-by-live-templates.html)
  - todo, fix, const, ifn, inn, thr, sbc, psvm, ...
  - 혹은 `⌘j`로 검색도 가능. (suggestion list)
  - gwt, ase, asnn, ...
- [analyze data flow](https://www.jetbrains.com/help/idea/analyzing-data-flow.html)
  - 특정 필드 커서 위치 후 data flow 액션 찾기
  - `⌥F7`과 비교하면 장점이 확연히 드러남
- debug
  - `⌥F8`: evaluate code fragment
  - [Analyze Java Stream operations](https://www.jetbrains.com/help/idea/analyze-java-stream-operations.html)
  - [디버그 도중 코드를 고치지 않고 예외 던지기가 가능](https://www.jetbrains.com/idea/whatsnew/#v2018-1-jvm-debugger)
- 유용한 단축키: https://www.jetbrains.com/help/idea/mastering-keyboard-shortcuts.html
  - `Ctrl` *2
  - `⇧` *2
  - `⌘O`, `⇧⌘O`, `⌥⌘O`, `⇧⌘A`
  - `⌘E`
  - `⌥⏎`
  - `⌃Space`, `⌃⏎Space`, `⇧⌘⏎`
  - `⌥↑`, `⌥↓`
- Http Client는 여전히 좋음. [이것도 덤으로](https://www.jetbrains.com/idea/whatsnew/#v2018-1-spring-boot)
- 탭 없애기(검색과 최근 파일 뷰 사용)
- 기타
  - `⌘7`
  - `⌥F1`
  - `⌘⇧8`
  - `^↑`, `^↓`
  - Refactor
    - `⌥⌘N`
    - `⌥⌘V`
    - `⌥⌘C`
    - `⌥⌘M`
    - `⇧F6`
    - `F6`
    - 모르겠으면 `^T`