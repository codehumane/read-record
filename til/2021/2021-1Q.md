
윽 2021년. 올해는 그 동안 못해 본 새로운 도전을 할 수 있기를.

# 01/01

## Two Sum II - Input array is sorted

- [어제의 전형적 HashMap 활용한 풀이](https://github.com/codehumane/algorithm/commit/10f7bedf4610b368886db9a320f5cd1fe6fc6cb3)를,
- [2 Pointers를 활용해 살짝 더 개선](https://github.com/codehumane/algorithm/commits/master)해 봄.

# 01/02

## Find the Duplicate Number

https://leetcode.com/explore/learn/card/binary-search/146/more-practices-ii/1039/

- 이전에 풀었던 '[연결 리스트에서 순환이 있는지를 탐지하고 순환이 시작되는 지점을 반환하는 문제](https://github.com/codehumane/algorithm/commit/b95d74c2a801b89226c4049a075ba1318305201e)'와 거의 동일.
- 다만, 연결 리스트 객체 생성 없이, 배열을 연결 리스트처럼 활용해야 함.
- 아래의 제약 사항 덕분에 이것이 가능.

> - nums.length == n + 1
> - 1 <= nums[i] <= n
> - All the integers in nums appear only once except for precisely one integer which appears two or more times.

- 2 포인터 기법으로 풀어야 하는 것은 3가지 제약 사항 때문.

> - Can you solve the problem without modifying the array nums?
> - Can you solve the problem using only constant, O(1) extra space?
> - Can you solve the problem with runtime complexity less than O(n2)?

### 교차점 계산

![](https://leetcode.com/problems/find-the-duplicate-number/Figures/287/first_intersection.png)

- 일단, 2개의 포인터 중 하나는 1씩 움직이고 다른 하나는 2씩 움직인다고 해보자.
- 순환이 존재한다면 2씩 움직이는 포인터가 언젠가는 1씩 움직이는 포인터를 따라잡게 됨.
- 순환이 시작되는 지점까지의 거리를 F라고 하고, 순환이 시작되는 점에서 교차점까지의 거리를 a, 순환의 거리는 C라고 하자.
- 2씩 움직이는 포인터는 1 포인터의 2배를 이동했으므로 `2(F + a) = F + nC + a` 식이 성립.
- 여기서의 `n`은 2 포인터가 몇 바퀴를 순환했는지를 의미하며, 실제 값은 중요하지 않음.
- 위 식을 정리하면 `F + a = nC`가 되고, 다시 `F = nC - a`로 정리.
- 그러니까, 처음부터 순환이 시작되는 지점까지 이동하면(F), 교차점을 시작으로 몇 바퀴 이동한 거리에서 a 만큼을 뺀 거리를 이동한 포인터와 만날 수 있음.

# 01/11

## Median of Two Sorted Arrays

https://leetcode.com/explore/learn/card/binary-search/146/more-practices-ii/1040/

- 어려웠음.
- [여기 솔루션](https://leetcode.com/problems/median-of-two-sorted-arrays/solution/)을 보고 나서야 풀기 시작.
- 막혔던 부분은 바로, 한 쪽 인덱스를 0~m 사이의 i로 정했으면, 다른 한 쪽의 인덱스는 무슨 값으로 설정해야 하냐는 것.
- 이는 `i + j = m − i + n − j (or: m - i + n - j + 1)`에서 도출할 수 있었음.
- 이를 정리하면 `j = (m + n + 1) / 2 - i)`가 됨.
- 구현은 [여기](https://github.com/codehumane/algorithm/commit/f2096bcd8722e89133e61227760e2973cdeaffc3)에.
- 에지 케이스도 풀이를 봐서 그렇지, 직접 생각하긴 쉽지 않았을 것.

# 01/14

## N-ary Tree Definition

https://leetcode.com/explore/learn/card/n-ary-tree/130/traversal/

- 각 노드에 N개 이하의 자식이 있는 트리.
- [trie](https://en.wikipedia.org/wiki/Trie)는 가장 자주 쓰이는 N-ary 트리 중 하나.
- 이진 트리 역시 N-ary 트리의 특수한 형태.

## N-ary Tree Traversal

- N-ary에서는 inorder 탐색에 대한 표준 정의도 없고, 정의한다 해도 자연스럽지 않고 비실용적.
- 그래서 preorder, postorder, level-order 탐색만을 언급.
- 아래의 3-ary 트리를 예시로 들어 각각의 탐색 순서를 보임.
  - preorder: A -> B -> C -> E -> F -> D -> G
  - postorder: B -> E -> F -> C -> G -> D -> A
  - lever-order: A -> B -> C -> D -> E -> F -> G

![3-ary tree](https://s3-us-west-1.amazonaws.com/s3-lc-upload/explore/cards/n-ary-tree/nary_tree_example.png)

# 01/16

## N-ary Tree Preorder Traversal

- https://leetcode.com/explore/learn/card/n-ary-tree/130/traversal/925/
- 구현은 [여기](https://github.com/codehumane/algorithm/commit/12a392bae0d090b92af449b70044eac759e3e0f0).

## N-ary Tree Postorder Traversal

- https://leetcode.com/explore/learn/card/n-ary-tree/130/traversal/926/
- 구현은 [여기](https://github.com/codehumane/algorithm/commit/27e84d4be3161ee31024ad18c9e2f34a57e538bf).

# 01/17

## N-ary Tree Level Order Traversal

- https://leetcode.com/explore/learn/card/n-ary-tree/130/traversal/915/
- 구현은 [여기](https://github.com/codehumane/algorithm/commit/c2bbb6967af266e11326013bd441b87c67092a32).

## Tree Traversal 비교

- 이전에 Binary Tree 순회는 재귀를 이용했고,
- 이번 N-ary Tree 순회는 순환문을 이용.
- binary가 n-ary가 된다고 달라지는 것은 크게 없음.
- 오히려 재귀냐 순환문이냐가 더 큰 차이.
- 아래는 각 구현들 비교표.

|  | Binary | N-ary
| - | - | -
| preorder | [recursive](https://github.com/codehumane/algorithm/blob/master/src/main/java/data/tree/BinaryTreePreOrderTraversal.java) | [iterative](https://github.com/codehumane/algorithm/blob/master/src/main/java/data/tree/BinaryTreePreOrderTraversal.java)
| inorder | [recursive](https://github.com/codehumane/algorithm/blob/master/src/main/java/data/tree/BinaryTreeInOrderTraversal.java) | X
| postorder | [recursive](https://github.com/codehumane/algorithm/blob/master/src/main/java/data/tree/BinaryTreePostOrderTraversal.java) | [iterative](https://github.com/codehumane/algorithm/blob/master/src/main/java/data/tree/NAryTreeTraversal.java#L46)
| level-order | [iterative](https://github.com/codehumane/algorithm/blob/master/src/main/java/data/tree/BinaryTreeLevelOrderTraversal.java) | [iterative](https://github.com/codehumane/algorithm/blob/master/src/main/java/data/tree/NAryTreeTraversal.java#L65)

# 01/21

## Binary Tree Inorder Traversal (Iterative)

- inorder 탐색을 [recursive로 구현](https://github.com/codehumane/algorithm/commit/22856c955425e77a43779fbec375ee59571aac92#diff-0f16e462b3d6404d2c6b103eaf05f61c44c5ea68e583cda9f2a9c9de0f1ca55e)했던 것을, [iterative 구현](https://github.com/codehumane/algorithm/commit/a035a440aba874537a415d7dfd833e66b6f263e7#diff-0f16e462b3d6404d2c6b103eaf05f61c44c5ea68e583cda9f2a9c9de0f1ca55e)으로 다시 작성.
- 그리고 [좀 더 적은 공간복잡도를 가진 iterative 방식](https://github.com/codehumane/algorithm/commit/d0661d66329ec8262b91bd95edff03797a2367ca#diff-0f16e462b3d6404d2c6b103eaf05f61c44c5ea68e583cda9f2a9c9de0f1ca55e)으로 개선.
