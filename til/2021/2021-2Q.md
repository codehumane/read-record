# 04/04

## Move Zeros

- [문제](https://leetcode.com/explore/learn/card/array-and-string/204/conclusion/1174/)
- [풀이](https://github.com/codehumane/algorithm/commit/f2d9e559b19f2d8e92425f4a1b65a3e537c67bcd)
- [여기 해답들](https://leetcode.com/problems/move-zeroes/solution/)도 함께 참고. 
- 지금 풀이는 3번째 방식과 유사. 처음엔 3번째 방식과 구현이 거의 같았는데, 가독성이 안 좋아 지금 형태로 변경했을 뿐. 하지만 결과를 놓고 보니, 가독성에 큰 차이는 없는 듯 하다.

# 04/05

## Queue & Stack Overview

https://leetcode.com/explore/learn/card/queue-stack/

- 배열에서는 인덱스로 임의의 원소에 접근.
- 하지만, 어떤 경우에는 프로세싱 순서를 제한하고 싶을 수도.
- 여기서는 2가지 프로세싱 순서인 FIFO와 LIFO를 다룸.
- 이에 대응하는 데이터 구조체는 큐와 스택.

## Queue 기본 구현

- 동적 배열과 큐의 시작을 나타내는 인덱스를 사용.
- 구현은 [여기](https://leetcode.com/explore/learn/card/queue-stack/228/first-in-first-out-data-structure/1366/)서 참고.
- 이는 직관적이지만 비효율적인 방법.
- 헤더 포인터가 오른쪽으로 이동할 때마다 공간이 낭비되기 때문.

## Circular Queue

- 앞선 비효율을 개선한 방식.
- 여기서는 고정-크기 배열과 2개의 포인터를 사용.
- 2개 포인터는 각각 시작 지점과 종료 지점을 나타냄.
- 낭비되는 공간을 재사용하는 것이 목적.

## Circular Queue 구현

- [여기에 간단히 구현](https://github.com/codehumane/algorithm/commit/aa259ec8a55bb00f064c5372c99b6e61966d6b32)
