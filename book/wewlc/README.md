# 레거시 코드 활용 전략

# 1부. 코드 변경의 메커니즘

## 소프트웨어 변경

### 소프트웨어 코드를 변경하는 네 가지 이유

- 이런 저런 내용이 나오지만, 결국 어떤 동작을 변경할 때 다른 동작들에는 영향이 없어야 한다는 이야기.
- 그리고 안전한 변경을 위해 영향 범위를 정확히 이해하는 것이 중요.

### 위험한 변경

> 클래스와 메서드를 새로 생성하지 않으면, 기존의 클래스와 메서드는 갈수록 비대해져서 결국 코드를 이해하기 어려운 지경에 이른다. 대규모 시스템에서 변경 작업을 할 때는 작업 대상을 이해하기 위해 어느 정도 시간이 걸릴 것을 감안해야 한다. 이때 좋은 시스템과 나쁜 시스템의 차이는 좋은 시스템일 경우 시스템에 익숙해질수록 마음이 편안해지고 변경 작업에 확신을 갖게 되지만, 나쁜 시스템의 경우 시스템을 알게 될수록 코드 변경 작업이 마치 호랑이를 피하기 위해 절벽에서 뛰어내리는 것 같은 느낌을 받게 된다는 점이다.

## 피드백 활용

### 시스템 변경의 방식

- 시스템 변경의 방식을 크게 2가지로 나눔.
- 편집 후 기도하기(Edit and Pray)
- 보호 후 수정하기(Cover and Modify)
- 편집 후 기도하기가 일반적.
- 이 방식에서 매우 신중하게 계획을 세우고, 대상 코드를 충분히 이해하는 등의 노력이 포함됨.
- 그러나 아무리 신중하게 주의를 기울여도 그에 비례해서 안정성이 높아진다는 보장은 없음.
- 이를 극복하기 위해 먼저 보호하는 것이 필요.

### 보호망

- 이 보호망은 다름 아닌 테스트.
- 작업 결과의 정확성을 보여주기 위함이기도 하며,
- 변경된 부분을 발견하기 위함이기도 함.
- 변경하고자 하는 부분만을, 의도대로 변경했는지 확인하는 것.

### 회귀 테스트

- 보통 회귀 테스트가 이를 위한 도구.
- 그러나 회귀 테스트는 애플리케이션 수준의 테스트.
- 피드백 주기가 길고, 빠른 문제 디버깅이 어려움.
- 커버리지도 높지 않은 것이 일반적.
- 그럼에도 불구하고 이런 상위 수준의 테스트는 다수 클래스들의 동작을 한 번에 확인할 수 있는 이점이 있음.

### 단위 테스트

- 단위테스트는 이 단점들을 보완.
- 실행 속도가 빠름.
- 좀 더 빠른 오류 위치 파악에 도움이 됨.

### 레거시 코드를 변경하는 순서

1. 변경 지점을 식별한다.
2. 테스트 루틴을 작성할 위치를 찾는다.
3. 의존 관계를 제거한다.
4. 테스트 루틴을 작성한다.
5. 변경 및 리팩토링을 수행한다.

### 테스트 작성 전 의존 관계의 제거

- 변경에 앞서 테스트를 작성해야 하는데,
- 깊고 거대한 의존성을 테스트 작성을 어렵게 함.
- 그래서 이 의존성을 제거하기 위한 리팩토링을 먼저 진행.
- 기본 타입 매개변수(primitive parameter)와 인터페이스 추출(extract interface)라 부르는 방법 사용.
- 이 같은 리팩토링을 테스트 없이 수행해도 충분히 안전하다고 저자가 말하는 게 인상적.

## 감지와 분리

- 테스트 시 (mock이 아닌) fake 클래스 만들어 감지와 분리의 과정을 보여줌.
- 테스트 하려는 클래스는 보통 다른 클래스들에 의존하기 마련.
- 이 의존 클래스가 테스트 환경에서 실행이 어려울 수 있음.
- 이 때, 이 의존 클래스를 가짜로 대체해서, 실제 실행 없이도 약속된 값을 반환하도록 하는 것이 '감지'.
- 한편, 이 의존 클래스는 또 다른 클래스, 그리고 그 클래스는 또 다른 클래스를 의존하고, 이런 식으로 확장되다 보면, 테스트 코드에 거의 모든 클래스를 정의해야 할 수도 있음.
- 이런 의존 관계를 끊어서 원하는 테스트에 집중할 수 있게 하는 것이 '분리'.
- 설명이 어려울 뿐, 우리가 흔히 하는 일들에 지나지 않음.
- 그리고 아래 내용이 인상적.

> 어떤 사람들은 가짜 객체를 사용하는 테스트를 가리켜서 "진짜 테스트가 아니다."라고 말하곤 한다. 어쨌든 실제 화면에 정말로 표시되는 내용을 보여주는 것은 아니기 때문이다. 따라서 금전 등록기 디스플레이 소프트웨어의 일부가 잘못 동작해도 우리는 이 테스트를 통해 소프트웨어의 오동작을 알아낼 수 없다. 물론 이것은 사실이지만, 그렇다고 해서 이 테스트가 실제 테스트가 아니라는 뜻은 아니다. 설령 실제 금전 등록기 화면과 정확히 동일한 픽셀로 구성되는 테스트를 설계할 수 있다고 한들, 그것이 모든 하드웨어에서의 동작을 의미할까? 그렇지는 않다. 하지만 이것 역시 실제 테스트가 아니라는 의미는 아니다. 우리는 테스트 루틴을 작성할 때 분할 후 정복(divide and conquer) 접근법을 취해야 한다. 이 테스트의 목적은 Sale 객체가 디스플레이에 어떤 영향을 미치는지 알려주는 것에 그치지만, 그렇다고 중요하지 않은 테스트라고 말할 수 없다. 적어도 버그의 원인이 Sale 클래스에 있는지 여부를 확인할 수는 있기 때문이다. 이러한 테스트를 통해 오류의 원인이 발생한 위치를 좁혀 나가고 디버깅 시간을 크게 절약할 수 있다.

## 봉합 모델

- 봉합이라는 단어가 참 어색.
- 테스트를 위해 감지와 분리를 해야 하는데,
- 이를 위해 설정 등으로 의존 대상을 갈아끼울 수 있어야 함을 의미.
- 책에서는 아래와 같이 정의.

> 봉합은 코드를 편집하지 않고도 동작을 변화시킬 수 있는 위치를 말한다.

# 2부. 소프트웨어 변경
