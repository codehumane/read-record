# 코딩 인터뷰 완전 분석

# big-O

- big-O, big-Θ, big-Ω 비교
- Θ는 O(상한)와 Ω(하한) 둘 다 의미
- big-O에 대한 기본적인 개념들 소개
- 상환시간에 대한 얘기도. ArrayList의 삽입 시간이, 배열이 꽉 찼을 때는 O(N)이 되는데, 이를 평소의 삽입 시간에 분배하려는 시도. 결과는 O(1).
- 로그의 밑은 상수항으로 취급되므로 무시해도 되지만, 지수에서는 큰 차이가 있음.
- 재귀적 수행 시간도 언급. 아래 코드는 O(N^2)가 아니라 O(2^N).

```java
int f(int n) {
  if (n <= 1) {
    return 1;
  }
  return f(n - 1) + f(n - 1);
}
```

# 기술적 문제

## 알고 있어야 할 것들

이진 트리의 균형을 맞추는 특정 방법 등의 복잡한 알고리즘 보다는 아래의 기본적인 것들을 알고 있어야 한다고 이야기.

자료구조

- Linked List
- Tree
- Tries
- Graph
- Stack & Queue
- Vector / ArrayList
- Hash Table

알고리즘

- BFS
- DFS
- Binary Search
- Merge Sort
- Quick Sort

개념

- Bit Manipulation
- Memory (Stack vs Heap)
- Recursion
- Dynamic Programming
- big-O 시간 & 공간

## 실제 문제 살펴보기

> 뻔한 내용이지만, 이렇게 정리하는 것도 마지막일 거라고 생각하고 일단 기록함.

경청하기

- 정확히 이해했는지 확인부터.
- 확실하지 않은 부분이 있다면 질문을 통해 짚고 넘어가야.
- 문제와 관련된 독특한 정보는 머릿 속에 기억(이유가 있기 때문에 주어지는 정보인 경우가 많음).
    - "정렬된 배열 두 개가 주어졌을 때"
    - "서버에서 반복적으로 수행되는 알고리즘을 설계하려고 하는데"

예제를 직접 그려보기

- 바로 문제를 푸는 대신, 예제를 직접 그려 보기를 권장.
- 실제 값을 대입해서 사용하고(단서를 찾고자),
- 충분히 큰 예제를 써야 하고(패턴을 찾고자),
- 특별한 예제는 지양(잘못된 가정을 피하고자. 예컨대 트리 중에서도 균형 잡힌 완벽 트리는 지양)

무식한 방법으로 일단 해보기

- brute force
- 일단 만들고,
- 시간과 공간복잡도를 이야기 하고,
- 최적화를 위한 토론의 시작점으로 삼기.

최적화

- 간과한 정보가 있는지 찾는다. 배열이 이미 정렬되어 있다던가 하는.
- 새로운 예제를 만들어 보기도.
- 공간과 시간의 실익을 따지고 균형 맞추기.
- 미리 계산해 두라. 해시 테이블에 넣어 두거나, 정렬을 해 둔다던가.

검토하기

- 바로 코딩에 들어가지 말고, 잠시 생각하며 이해를 확실히 한다.
- 정확히 무엇을 작성해야 하는지 모른다면, 시간도 오래 걸리고 심각한 실수도 하기 마련.

코드 작성하기

- 모듈화된 코드를 사용. 책에서 말하는 내용은 composed method의 의미.
- 필요하다면 다른 클래스나 구조체 사용.
- 좋은 변수명.

테스트

- 개념적 테스트부터 시작. (코드를 한 줄씩 읽어 내려가며 어떤 일을 수행하는지 분석하는)
- 작은 규모부터 테스트.
- Null, 단일 원소, 극단적 입력 등 특별한 경우를 테스트.

