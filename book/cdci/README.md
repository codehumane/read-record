# 코딩 인터뷰 완전 분석

# big-O

- big-O, big-Θ, big-Ω 비교
- Θ는 O(상한)와 Ω(하한) 둘 다 의미
- big-O에 대한 기본적인 개념들 소개
- 상환시간에 대한 얘기도. ArrayList의 삽입 시간이, 배열이 꽉 찼을 때는 O(N)이 되는데, 이를 평소의 삽입 시간에 분배하려는 시도. 결과는 O(1).
- 로그의 밑은 상수항으로 취급되므로 무시해도 되지만, 지수에서는 큰 차이가 있음.
- 재귀적 수행 시간도 언급. 아래 코드는 O(N^2)가 아니라 O(2^N).

```java
int f(int n) {
  if (n <= 1) {
    return 1;
  }
  return f(n - 1) + f(n - 1);
}
```

# 기술적 문제

## 알고 있어야 할 것들

이진 트리의 균형을 맞추는 특정 방법 등의 복잡한 알고리즘 보다는 아래의 기본적인 것들을 알고 있어야 한다고 이야기.

자료구조

- Linked List
- Tree
- Tries
- Graph
- Stack & Queue
- Vector / ArrayList
- Hash Table

알고리즘

- BFS
- DFS
- Binary Search
- Merge Sort
- Quick Sort

개념

- Bit Manipulation
- Memory (Stack vs Heap)
- Recursion
- Dynamic Programming
- big-O 시간 & 공간

## 실제 문제 살펴보기

> 뻔한 내용이지만, 이렇게 정리하는 것도 마지막일 거라고 생각하고 일단 기록함.

경청하기

- 정확히 이해했는지 확인부터.
- 확실하지 않은 부분이 있다면 질문을 통해 짚고 넘어가야.
- 문제와 관련된 독특한 정보는 머릿 속에 기억(이유가 있기 때문에 주어지는 정보인 경우가 많음).
    - "정렬된 배열 두 개가 주어졌을 때"
    - "서버에서 반복적으로 수행되는 알고리즘을 설계하려고 하는데"

예제를 직접 그려보기

- 바로 문제를 푸는 대신, 예제를 직접 그려 보기를 권장.
- 실제 값을 대입해서 사용하고(단서를 찾고자),
- 충분히 큰 예제를 써야 하고(패턴을 찾고자),
- 특별한 예제는 지양(잘못된 가정을 피하고자. 예컨대 트리 중에서도 균형 잡힌 완벽 트리는 지양)

무식한 방법으로 일단 해보기

- brute force
- 일단 만들고,
- 시간과 공간복잡도를 이야기 하고,
- 최적화를 위한 토론의 시작점으로 삼기.

최적화

- 간과한 정보가 있는지 찾는다. 배열이 이미 정렬되어 있다던가 하는.
- 새로운 예제를 만들어 보기도.
- 공간과 시간의 실익을 따지고 균형 맞추기.
- 미리 계산해 두라. 해시 테이블에 넣어 두거나, 정렬을 해 둔다던가.

검토하기

- 바로 코딩에 들어가지 말고, 잠시 생각하며 이해를 확실히 한다.
- 정확히 무엇을 작성해야 하는지 모른다면, 시간도 오래 걸리고 심각한 실수도 하기 마련.

코드 작성하기

- 모듈화된 코드를 사용. 책에서 말하는 내용은 composed method의 의미.
- 필요하다면 다른 클래스나 구조체 사용.
- 좋은 변수명.

테스트

- 개념적 테스트부터 시작. (코드를 한 줄씩 읽어 내려가며 어떤 일을 수행하는지 분석하는)
- 작은 규모부터 테스트.
- Null, 단일 원소, 극단적 입력 등 특별한 경우를 테스트.

## 최적화 및 문제풀이 기술 #5: 자료구조 브레인스토밍

다른 내용들은 익숙한데, 이 부분은 그렇지 못해서 따로 기록까지 진행. 일단, 여기서 다루는 문제는 아래와 같음.

> 임의의 숫자를 만들어 낸 뒤 확장 가능한 배열에 차례로 저장한다. 새로운 입력이 들어올 때마다 중간값(median)을 구하려면 어떻게 해야 하는가?

이를 풀기위한 접근법으로 여러 자료구조를 먼저 떠올림.

- 연결리스트
- 배열
- 이진트리
- 힙

연결리스트는 배제. 수열을 정렬하거나 특정 수에 바로 접근하기에는 약한 구조. 배열은 가능하긴 함. 배열을 매번 정렬된 상태로 유지하면 됨. 하지만 비용이 작지는 않음. 이진트리는 배열보다는 나음. 원소 삽입마다 정렬된 상태를 유지하기 쉽기 때문. 그리고 원소 갯수가 홀수이면, 트리의 루트 원소가 중앙값이 됨. 하지만, 짝수일 때의 중앙값은 가운데 두 값의 평균을 취해야 한다. 이진트리가 괜찮긴 하지만 짝수인 경우를 생각하면 좀 더 고민이 필요해 보임. 마지막으로 힙. 힙을 그냥 쓰면 안 되고, 두 개를 사용하는 것을 고려. 한 쪽은 작은 수들을, 다른 한 쪽은 큰 수들을 두고 관리. 이진트리의 한계가 극복됨.

참고로, 중앙값에 대한 정의는 [여기](https://ko.wikipedia.org/wiki/%EC%A4%91%EC%95%99%EA%B0%92)를 참고. 그리고 이진트리와 힙의 차이는 [여기](https://cs.stackexchange.com/questions/27860/whats-the-difference-between-a-binary-search-tree-and-a-binary-heap) 설명만으로도 충분해 보임.

