# Get Your Hands Dirty on Clean Architecture

# What's Wrong with Layers?

- 레이어드<sup>layered</sup> 아키텍처의 좋은 점에 대해 언급.
- 좋은 레이어드 아키텍처에서, 우리의 선택지는 열려 있으며, 요구사항 변화를 빠르게 수용.

> keeping our options open and are able to quickly adapt to changing requirements and external factors. And if we believe Uncle Bob, this is excatly what architecture is all about.

- 하지만, 전통적인 레이어 아키텍처에는 열린 측면이 많으며, 이것이 나쁜 습관이 파고들게 만든다고 함. 이는 시간이 지날수록 변경을 어렵게 만듦.
- 여기서의 전통적 아키텍처는 `웹 -> 도메인 -> 영속` 구조를 가리킴.

## It Promotes Database-Driven Design

- 우리는 비즈니스를 다루는 규칙이나 정책 모델을 만들고자 함.
- 주로 상태가 아닌 행위를 모델링.
- 상태가 중요하긴 하나, 행위가 상태를 바꾸며, 따라서 비즈니스를 이끌어 나가는 주체는 행위.
- 하지만, 전통적 레이어드 아키텍처에서는 DB가 토대가 됨.
- 모든 것이 영속 레이어 위에 지어지는 것.
- ORM도 종종 DB 중심 아키텍처의 주역.
- ORM 엔티티들이 영속성 레이어의 일부가 되어,
- 비즈니스 규칙과 영속성 측면을 혼합시킴.
- 서비스들이 비즈니스 모델로 영속성 모델을 사용하게 되면,
- 도메인 로직 뿐만 아니라 로딩 방식(eager vs lazy), DB 트랜잭션, 캐시 플러시 등도 다루게 됨.
- 레이어드 아키텍처가 의도한 것과 반대로, 변경이 점점 어려워지는 것.

## It's Prone to Shortcuts

- 영속성 레이어에 도메인 엔티티가 섞이고,
- 유틸리티나 헬퍼 등의 추가로 영속성 레이어가 점점 더 비대해짐.
- 레이어드 아키텍처에서는 자기 자신이나 아래의 레이어만 접근만을 허용.
- 그러다 보니 자신보다 아래 레이어에 컴포넌트들을 추가하게 되는 경향.
- 이렇게 쉽게 아래 쪽 레이어를 비대하게 만드는 것을 저자는 "shortcut mode"라 칭함.

## It Grows Hard to Test

- 레이어가 스킵되기도.
- 컨트롤러가 도메인 레이어를 거치지 않고,
- 엔티티에 직접 접근하여 필드 한 두개를 조작하는 것.
- 이는 2가지 단점을 가짐.
- 먼저, 웹 레이어에 도메인 로직을 구현하게 됨.
- 처음엔 필드 하나만 조작했겠지만, 기능이 추가될 수록 웹 레이어에는 도메인 로직이 산재하게 됨.
- 다음으로, 웹 레이어 테스트에서, 도메인 레이어 뿐만 아니라 영속성 레이어도 목으로 대체해야 함.
- 이는 복잡성의 증대.
- 테스트를 위한 준비 과정에 많은 시간 소요.
- 종종 적은 테스트 코드로 이어짐.

## It Hides the Use Cases

- 로직이 산재하면 기능을 추가할 때 어디에 해야 할지 막막.
- 게다가 레이어드 아키텍처는 "넓이"에 대한 규칙이 없음.
- 시간이 지날수록 광범위한(여러 유스 케이스들을 다루는) 서비스가 만들어짐.
- 이런 서비스들은 영속 레이어에 많은 의존성을 가지고,
- 웹 레이어의 많은 컴포넌트들이 이 레이어에 의존.
- 이런 서비스는 테스트하기 어렵고,
- 기능을 추가할 적절한 서비스 산정이 어려움.
- 하나의 유스 케이스만을 담당하는, 꽤나 전문화된 좁은 도메인 서비스가 있다면 어떨까?
- 사용자 등록이라는 유스 케이스를 찾기 위해 `UserService` 대신 `RegisterUserService`를 열어보게 된다면?

## It Makes Parallel Work Difficult

- 더 많은 사람이 함께 일할 때 더 빠를 수 있으려면,
- 병렬 작업이 가능한 아키텍처이어야 함.
- 넓은 서비스는 이를 어렵게 만듦.
