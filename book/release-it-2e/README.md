# Living in Production

- feature complete != production ready
- crash, hang, lose data, violate privacy, lose money, crazy real uses, globe-spanning taffic, virus writing mobs, …
- 최선의 계획을 세우더라도 나쁜 일이 일어난다는 것을 받아들여야 함. 따라서, 할 수 있는 것들을 최대한 하되, 어떤 심각한 상황에서도 전체 시스템이 회복될 수 있어야 함.

## Aiming for the Right Target

- "고객의 첫 번째와 마지막 이름은 필수고, 중간은 선택이에요"와 같은 테스트를 통과하기 위함이 아님.
- 대신, "design for production"

## The scope of the Challenge

- 사용자는 늘어나고, 더 높은 수준의 가용성이 요구됨.
- 빌드 비용이 저렴하고, 사용자에게 유용하고, 운영 비용이 적은 소프트웨어를 빠르게 만들어내야 함.
- 조그마한 워드프레스에 적절한 설계는 대규모 확장과, 트랜잭션, 분산 시스템 등의 요구에 실패할 것.

## A Million Dollars Here, a Million Dollars There

- 설계와 아키텍처 결정은 또한 재정적 결정.
- 이런 결정들은 구현 비용과 더불어 후속 비용(가용성이나 배포 비용 등의 운영을 가리키는 듯)도 함께 고려해야 함.
- 기술적 그리고 재정적 관점은 이 책에서 반복적으로 다루는 중요한 테마.

## Use the Force

- "Use the Force"가 무슨 말인가 했더니, 스타워즈에 나오는, 앞을 내다보라는 식의 말인 것 같다.
- 저자는 열성적인 애자일 지지자이긴 하지만, 초기 결정의 중요성에 대해 말하고 있음.
- 이 결정이 시스템의 궁극적 모습에 지대한 영향을 미치기도 하고, 때로는 돌이킬 수 없기도 함.
- 앞으로 책에서, 어떤 문제에 대한 대안을 소개하고, 이들이 선택된 이후에 어떤 영향을 미치는지 살펴본다고 함. 궁금.

## Pragmatic Architecture

- 저자는 아키텍트를 2개로 분류하는데, 하나는 상아탑<sup>ivory towel</sup>이고, 다른 하나는 실용주의.
- 높은 추상화를 추구하기 보다는 현실적 문제를 다룸. 메모리 사용량, CPU 요건, 대역폭, 하이퍼스레딩과 CPU 바인딩의 이점과 단점 등을 논의.
- 특별한 이야기는 아님. 개인적으로는 지면이 아까운..

# Case Study: The Exception That Grounded an Airline

- 정기적인 DB 유지보수가 있었고,
- 이 때, A라는 DB로부터 B라는 DB로 페일오버가 예정됨.
- 서비스에 이상이 없는지를 확인할 수 있는 모니터링과 함께,
- 무중단 DB 페일오버를 수동으로 진행.
- 문제 없이 완료 후 작업은 모두 끝남.
- 하지만 몇 시간 후 항공사 시스템에 전면 장애가 발생.
- 장애 발생 시의 즉각적인 대응과 포스트 모텀 등을 이야기 한 뒤(이런 부분들이 잼있었음),
- 문제의 원인이 된 코드도 보여줌. CF라는 시스템은 아래의 코드만으로 이뤄진 애플리케이션이 실행되고 있었다고 함.

```java
public class FlightSearch implements SessionBean {

    private MonitoredDataSource connectionPool;

    public List lookupByCity(...) throws SQLException, RemoteException {
        Connection conn = null;
        Statement stmt = null;

        try {
            conn = connectionPool.getConnection();
            stmt = conn.createStatement();

            // ...
        } finally {
            if (stmt != null) {
                stmt.close();
            }
            if (conn != null) {
                conn.close();
            }
    }
}
```

- `stmt.close()`가 SQLException을 던지기 때문.
- 데이터베이스의 페일오버 시 연결이 끊겼고, 이 때 `stmt.close()`의 호출이 예외를 발생시켰으며, 이로 인해 커넥션이 종료되지 않고, 리소스가 누수되어서 발생한 문제.

# Stabilize Your System

1. 엔터프라이즈 소프트웨어는 냉소적이어야 함.
    - 나쁜 것이 일어날 것을 예상하고, 그것이 일어났을 때 놀라지 않는 것.
    - 스스로를 또한 믿지 않기 때문에 장애 시의 대비책도 마련.
    - 다른 시스템과 너무 밀접<sup>intimate</sup>해지는 것을 거부. 다치는 것을 염려하기 때문.
    - 앞선 항공사 사례에서의 예외는 충분히 회의적이지 않았음.
2. 낮은 안정성은 많은 실질적 비용을 초래. 수익은 물론, 평판도 마찬가지.
3. 좋은 안정성에 꼭 많은 비용이 들일 필요는 없음.
    - 아키텍처나 설계, 저수준 구현 시 많은 안정성을 위한 레버리지 포인트들이 존재.
    - 이 레버리지는 기능적 요구사항과 상충되는 길이 아니며,
    - 안정적이지 못한 것과 안정적인 것을 만드는데 들어가는 시간은 동일하다고.
    - (하지만 갑자기 자본론이 떠오름. 아쉬움)

## Defining Stability

대부분의 사람들은 "안정성<sup>stability</sup>"을 아래와 같이 정의한다고 함.

> 강건한 시스템은 일시적 충격<sup>impulse</sup>이나, 지속적인 스트레스<sup>stress</sup>, 컴포넌트의 실패에 상관 없이, 트랜잭션 처리를 지속함.

여기서의 트랜잭션과 시스템의 의미는 각각 다음과 같음.

- 트랜잭션: 시스템에 의해 처리되는 일의 단위를 추상화한 것. DB 트랜잭션 X. "customer places order"와 같이 다른 시스템(카드사 등)과의 통합이 포함될 수도.
- 시스템: 사용자의 트랜잭션을 처리하기 위한 하드웨어, 애플리케이션, 서비스의 상호 의존적이고 완전한 집합.

## Extending Your Life Span

1. 시스템 수명에 대한 주요 위험 요소는 메모리 누수와 데이터 성장이라고 함.
2. 이 둘은 모두 테스트 기간에는 잡히기 어려운 것들. (주로 긴 시간을 두고 운영할 때 생기는 문제이기 때문)
3. 테스트에 관해서는 머피의 법칙을 따르자. 테스트 안 한 것이 문제가 됨. 42시간이 지나야 생기는 메모리 누수, 자정이 지나야 생기는 충돌 문제 등.
4. 그런데 이런 장기적(?) 버그는 어떻게 찾을 수 있을까.
5. 개발 장비를 하나 마련해서 JMeter, Marathon 등으로 장기 버그를 테스트. 심한 부하를 주기 보다는, 적정한 양의 요청을 지속적으로 보내고, 이따금 일정 기간 동안에는 적은 양의 요청을 보내게 하라(커넥션 풀이나 방화벽 시간 제한 등의 문제를 잡을 수 있다고 함).
6. 돈이 문제가 된다면 적어도 중요한 부분만이라도 하라.
7. 이런 테스트가 없다면, 프로덕션 환경 = 장기 테스트 환경

## Failure Modes

1. 갑작스런 충격이나 과도한 긴장<sup>strain</sup>(스트레스가 가해진 모습을 가리킴)은 재앙적 실패<sup>catastrophic failure</sup>를 불러올 수 있음.
2. 일부 컴포넌트에 장애가 생기고, 이것에 의존하는 다른 컴포넌트에 급속도로 장애가 전파되는 것을 가리킴.
3. 다양한 고장 모드는 반드시 일어남. 충격을 수용하고 나머지 시스템을 보호하는 안전한 고장 모드를 만들어야 함.
4. 이런 종류의 자가 보호가 전체 시스템의 회복 탄력성<sup>resilience</sup>을 결정.
5. Chiles라는 사람은 이를 가리켜 "crackstoppers"라고 부름.

## Stopping Crack Propagation

고장 모드 설계는 항공사 사례에 적용 가능함. SQLException를 부적절하게 핸들링 했던 것이 원인인데, 이를 막을 수 있었던 지점을 저수준부터 고수준까지 소개. 먼저, DB 연결 설정부터.

1. 가용한 풀이 없으면 요청 스레드를 막도록 설정되어 있었기 때문에, 결국 요청을 처리하는 모든 스레드를 가두게 됨.
2. 자원이 고갈되면 더 많은 커넥션을 생성하도록 설정할 수도 있었을 것. (새로 바뀐 DB에 대해 새로운 커넥션을 맺을 수 있었을 것)
3. 또는 호출자를 영원히 멈추게 하는 대신, 제한된 시간 동안만 막도록 설정할 수도 있었을 것.
4. 참고로, 아래 내용은 HikariCP의 `maximumPoolSize`에 대한 설명. 더불어, 이런 글([Hikari, About Pool Sizing](https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing))도 있음. 예전에는 못 봤던 문서.

> "This property controls the maximum size that the pool is allowed to reach, including both idle and in-use connections. Basically this value will determine the maximum number of actual connections to the database backend. A reasonable value for this is best determined by your execution environment. When the pool reaches the size, and no idel connections are available, calls to getConnection() will block for up to `connectionTimeout` milliseconds before timing out."

다음으로, CF가 다른 애플리케이션을 호출할 때 RMI를 사용한 것에 대해.

1. RMI는 기본적으로 타임아웃이 없음. 호출이 블럭되면 영원히 대기.
2. RMI 소켓에 타임아웃을 설정하는 것이 좋았을 것.
3. 혹은, HTTP 요청을 타임아웃과 함께 사용.
4. 블럭된 스레드를 클라이언트가 버리는 것도 방법.

좀 더 큰 수준에서 본다면.

1. CF 서버를 2개 이상의 서비스 그룹으로 나누는 것도 방법.
2. 모든 그룹이 여전히 다 죽을 수도 있지만, 항상 그런 것은 아님.

이보다 더 큰 수준의 아키텍처 이슈로 본다면.

1. CF에서 요청/응답 메시지 큐를 사용할 수도 있음.
2. 혹은 튜플 스페이스<sup>tuple space</sup>에서 검색 조건에 맞는 항공편을 찾을 수도.
3. 아키텍처의 결합도가 높아질수록, 오류가 전파될 가능성은 높아짐.
4. 반대로 말하면, 아키텍처 결합도가 낮을 수록 충격을 흡수함. 에러를 증폭시키는 대신 줄여주기도.

## Chain of Failure

1. 하나의 작은 이슈가 다른 이슈를 낳고, 그리고 이로 인해 또 다른 이슈가 생기고, ...
2. 이런 일련의 사건들이 모두 똑같이 일어날 확률은 매우 낮음. 그러나 각각은 독립사건.
3. 그러나, 사건의 조합은 독립적이지 않음. 특정 지점이나 레이어의 장애는 이에 의존하는 다른 지점의 장애를 일으킬 가능성이 큼.
4. 예컨대, DB가 느려지면 애플리케이션 서버들의 메모리는 고갈될 가능성이 높음.
5. 3가지 용어 정의를 잠깐 하고 가면 아래와 같음.

```
Fault: 소프트웨어의 내부 상태를 비정상적으로 만드는 상황. 지연 버그, 체크되지 않은 경계 조건이나 외부 인터페이스 등에 의한 것.
Error: 비정상적인 행위가 가시적인 것. 트레이딩 시스템이 갑자기 100억 달러를 사들인다거나 하는 것.
Failure: 응답하지 않는 시스템. 
```

6. 실패<sup>fault</sup>는 틈을 열고, 에러가 되며, 에러는 장애가 됨.
7. 당연하게도, 높은 수준의 결합도를 가진 복잡한 시스템은 에러로 이어질 수 있는 실패 전파의 경로가 많음.
8. 가능한 실패에 대해 미리 준비할 수 있는 한 가지 방법은 모든 외부 요청, I/O, 리소스 사용을 살피고, 잘못된 수 있는 경우를 따져보는 것.

```
초기 연결이 맺어지지 않는다면?
연결을 맺는데 10분이 걸린다면?
연결은 맺었는데, 다시 끊어진다면?
연결을 맺었는데, 응답이 오지 않는다면?
질의 응답이 오는데 2분이 걸린다면?
10,000개의 요청이 동시에 들어온다면?
`SQLException` 에러 메시지를 로깅하는데 디스크가 꽉 차있다면?
```

9. 실패는 반드시 발생하며, 모든 것을 예방할 수는 없음.
10. 그리고 이 실패가 에러가 되지 않도록 막음과 동시에 실패나 에러를 감수할 것인지 결정도 해야함.

# Stability Antipatterns

## Integration Points

1. 저자는 1996년 이래로 단일 모드로 된 웹사이트를 본 적이 없다고 함.
2. 모든 프로젝트는 통합된 프로젝트였으며, [나비](https://www.safaribooksonline.com/library/view/release-it-2nd/9781680504552/images/stability/butterfly.png)나 [거미](https://www.safaribooksonline.com/library/view/release-it-2nd/9781680504552/images/stability/spiderweb_orderly.png) 형태 중 하나.
3. 이런 연결들은 모두 통합 지점이며, 각각은 모두 시스템을 붕괴시킬 수 있는 요소.
4. 책에서는 통합 지점을 가리켜 "number-one killer of systems"라고 표현하기도 함.
5. 모든 소켓, 프로세스, 파이프, 원격 프로시저 호출, 데이터베이스 연결 등이 여기에 해당.
6. 뒤이어서, 통합 지점이 문제가 될 수 있는 몇 가지 상황과 각각에 대한 대처 방안에 대해 살펴봄.

### SOCKET-BASED PROTOCOLS

1. 많은 상위 수준의 통합 프로토콜은 소켓 위에서 실행되며, 프로토콜들은 소켓이 문제가 되는 경우를 위한 실패 모드를 지원.
2. 가장 단순한 실패 모드는 원격 시스템이 연결을 거부할 때 발생. 하지만, 연결 거부는 주로 문제가 되지 않음. 많은 언어들이 API를 통해 연결 실패가 발생할 수 있음을 잘 알려주기 때문.
3. 한 가지 주의할 것은 연결할 수 없음을 발견하는 데 오랜 시간이 걸릴 수 있다는 것.
4. 잠시, TCP/IP 네트워킹에 대해 소개하고 넘어감.

> 네트워크 연결을 표현하는 많은 그림들은 박스와 화살표를 사용함. 하지만, 이는 추상화한 것을 다시 또 추상화한 것. 네트워크 "연결"은 논리적 언어. 네트워크 상에서 우리가 볼 수 있는 것은 단지 패킷(물론, 패킷 또한 추상화 된 것. 전기와 광자, ...). 이들 패킷은 TCP/IP의 IP에 해당. TCP는 불연속적인 패킷들의 주고 받음을 어떻게 연속적인 연결로 보이게 할 것인가에 대한 약속.
> 
> TCP는 연결을 열기 위해, "three-way handshake"를 사용. 호출자가 SYN 패킷을 원격 서버의 포트에 전달. 아무도 포트에 대해 리스닝하고 있지 않다면, 즉각 TCP "reset" 응답을 반환. 호출 애플리케이션은 예외 또는 잘못된 응답 값을 받게 됨. 이 과정은 매우 짧은 시간 내에 일어나며, 같은 스위치로 연결된 장비라면 10ms 이하로 소요. 목적지 포트에 대해 리스닝하고 있는 애플리케이션이 있다면, 원격 서버는 SYN/ACK 패킷(연결을 받을 준비가 됐다는 의미로)을 응답. 이 응답을 받은 호출자는 다시 ACK를 전송함. 이 세개의 패킷들이 바로 "연결"을 만들어 냄. 애플리케이션들은 이제 데이터를 서로 주고 받을 수 있음.

5. 포트는 "리스닝 큐"를 가지고 있음. 이는 얼마나 많은 대기 연결(SYN은 보내졌지만, SYN/ACK를 응답하지 않은)을 네트워크 스택에 허용할지를 정의. 리스닝 큐가 꽉 차면, 이후의 연결 시도는 재빨리 거부됨. 리스닝 큐는 최악의 장소.
6. 소켓이 상태를 부분적으로 형성하고 있는 동안, open 상태의 스레드는 OS 커널 안에서 대기하게 됨. 원격 애플리케이션이 연결을 받아들이거나, 커넥션이 타임아웃이 될 때까지.
7. 연결도 되고 요청도 보냈지만, 원격 서버가 요청을 읽어들이거나 응답을 반환하는 데 오랜 시간이 걸릴 수도 있음. read 요청(open 상태의 스레드와 마찬가지로) 또한 대기 상태가 될 수 있음.
8. 네트워크 실패의 종류는 2가지. 빠르거나 느리거나. 빠른 실패는 "Connection refused" 같은 예외를 즉각 일으킴. 느린 실패(중단된 ACK 같은)는 예외를 던지기까지 몇 분 동안 스레드를 대기시킬 수 있음. 대기된 스레드는 다른 트랜잭션을 처리할 수 없고, 전체 가용 자원은 줄어듦. 만약, 모든 스레드가 대기하게 되면, 서버는 결국 중단됨.

> "Clearly, a slow response is a lot worse than no response."

### THE 5 A.M. PROBLEM

1. 매일 아침 5시만 되면 행이 걸렸고, 재시작으로 항상 문제가 해결됨.
2. 이 문제가 생기고 나서 3일이 되는 날 스레드 덤프를 생성.
3. 인스턴스는 살아 있었지만, 요청을 처리하는 모든 스레드가 Oracle JDBC 라이브러리 부근에서 블럭 상태. 특히 OCI 호출부 안에서.
4. synchronized 메서드를 진입하려고 대기하는 스레드를 제외하면, 활성화 된 스레드들은 모두 저수준의 소켓 읽기나 쓰기 호출에 사용되고 있는 것으로 보였음.
5. 다음 단계는 tcpdump 또는 ethereal(현재는 Wireshark라고 불리는).
6. 이 도구를 통해 살펴보니, 애플리케이션 서버에서 일부 패킷들이 데이터베이스 서버로 전송됐지만, 응답이 없는 상태였음.
7. 하지만, 모니터링 도구를 통해 살펴보면 데이터베이스는 살아 있으며 건강하다고 표시됨.
8. 블럭 상태의 락은 없었으며, 큐 갯수는 0개였고, I/O 비율은 정말 낮았음.
9. 그러고 나서 하루가 지나고 문제는 어김 없이 다시 발생.
10. 이번에는 데이터베이스 네트워크 트래픽을 살펴볼 수 있었음.
11. 그런데 트래픽이 전혀 없었음. 이것이 큰 단서.
12. 앞서 소켓 연결의 추상화를 언급했었음. 양쪽의 컴퓨터 메모리에 소켓이 연결 상태라고 표시되어 있으면 그게 곧 연결인 것. 하루 종일 1개의 패킷도 보내지 않는 중이라고 하더라도, 라우트가 변경되더라도, 물리적 링크가 다시 연결되더라도 말이다.
13. 방화벽은 특수화 된 라우터에 지나지 않음.
14. 각 방화벽 내부에는 접근 제어 목록 집합이 정의되어 있음.
15. SYN 패킷이 들어오면 방화벽은 허용하거나(목적지로 전달), 거부하거나(TCP 리셋 패킷을 다시 돌려줌), 무시하거나(응답 없이 패킷을 버림) 중 하나를 취함.
16. 연결이 허용되면 방화벽은 이 엔트리를 내부 테이블에 기록하고, 엔드포인트가 일치한 이후 패킷들에 대해서는 요청을 라우팅해 줌.
17. 이 방화벽 이야기가 아침 5시 문제와 무슨 관계가 있을까?
18. 핵심은 방화벽의 연결 허용 기간이 유한하다는 것. TCP는 무한한 기간의 연결을 허용하더라도 말이다.
19. 마지막 패킷 시간으로부터 많은 시간이 지났다면, 이 연결을 죽었다고 간주하고 이후에 들어오는 패킷을 버림(무시).
20. 라우터로써, 방화벽은 ICMP 리셋을 전달할 수도 있었으나, 악의적인 공격에 의한 ICMP 트래픽을 억제하기 위해 설정되어 있었음.
21. 결국, 반쯤 열린 소켓은 읽기나 쓰기 시도시 TCP 리셋이나 에러를 받을 수 없었음. 단지, ACK를 기다리고 있을 뿐.
22. JDBC 연결을 사용하기 전에 "SELECT SYSDATE FROM DUAL" 같은 SQL로 유효성을 검증할 수도 있으나, 이 또한 스레드를 행 걸리게 하는 일일 뿐.
23. 대신에 오라클의 dead connection detection을 사용. 이 자체의 기능이 필요했다기 보다, 단지 주기적으로 클라이언트에게 PING 요청을 보내게 함으로써, 방화벽에 마지막 패킷 시간을 계속 최신으로 유지하기 위함.
24. 여기서의 교훈은 추상화된 수준에서 해결되지 않는 문제들이 있다는 것. 때로는 두 단계 정도 아래로 내려와 현실을 마주해야 할 필요도 있음.

### HTTP PROTOCOLS

1. HTTP 기반의 프로토콜은 소켓을 사용함. 따라서, 앞서 언급했던 문제들에 취약.
2. 여기에 HTTP 자체의 이슈들도 더해짐. 예컨대, 아래와 같은 것들이 있음.
   - 수신자가 TCP 커넥션 연결을 받아들였지만, HTTP 요청에 대한 응답을 하지 않음.
   - 연결은 받아들였지만, 요청을 읽어들이지 못할 수도 있음. 요청 바디가 너무 큰 경우, 수신자의 TCP 윈도우를 꽉 차게 하고, 호출자의 TCP 버퍼도 차게 되면서, 소켓의 쓰기가 블럭될 수 있음.
   - 호출자가 반환한 응답 상태를 호출자가 다루는지 모를 수 있음.
   - 수신자가 반환한 컨텐츠 타입을 호출자가 이해하지 못할 수 있음. 예를 들어, JSON 요청을 했는데 404 에러 HTML 페이지가 반환된다거나.
   - 수신자가 JSON을 응답한다고 하면서 실제로는 평문을 반환할 수도 있음.
3. 세부적인 제어가 가능한 클라이언트 라이브러리를 사용하라. (커넥션과 읽기 타임아웃 등이 제공되는)
4. 응답을 바로 도메인 객체로 매핑하려는 라이브러리는 쓰지 말아라. 기대를 충족하는 응답인지를 먼저 확인할 수 있어야 한다.

### VENDOR API LIBRARIES

그냥, 왠만해서는 쓰지 말라는 이야기.

### COUNTERING INTEGRATION POINT PROBLEMS

1. 통합이 없는 시스템은 드물고, 대부분 쓸모도 없음.
2. 통합 지점을 어떻게 안전하게 만들 수 있을까?
3. 가장 효과적인 안정성 패턴은 Circuit Breaker와 Decoupling Middleware(뒤에서 다루는 내용들).
4. 테스팅 또한 도움이 됨.
    - 냉소적인 소프트웨어는 형태나 기능 위반(잘못된 형태의 헤더나 비정상적인 연결 종료 등)을 다룰 수 있어야 하고,
    - 이를 확인하기 위해서 Test Harness가 도움이 됨.

### REMEMBER THIS

1. Beware this necessary evil: 모든 통합 지점은 결국엔 어떤 식으로든 실패함.
2. Prepare for the many forms of failure: 통합 지점 실패는 다양한 형태를 띰. 다양한 네트워크 오류부터 문법 에러까지. 그리고 약속된 프로토콜을 통해 에러가 오는 감사한 경우도 없을 것.
3. Know when to open up abstractions: 통합 지점 실패를 디버깅할 때는 종종 저수준을 살펴야 하기도. 패킷 스니퍼나 네트워크 진달 도구가 도움이 됨.
4. Failure propagate quickly: 코드가 충분히 방어적이지 않다면, 원격 시스템의 실패는 보통 실패 전파로 이어짐.
5. Apply patterns to avert integration point problems: Circuit Breaker, Timeouts, Decoupling Middleware, Handshaking 등이 도움이 될 것.

## Chain Reactions

1. 스케일 아웃을 취하고 있다고 하더라도, 부하 관련 충돌이나 자원 누수와 같은 결함은 연쇄 반응으로 이어질 수 있음.
   - 예를 들어, 클러스터에서 특정 노드가 부하로 인해 문제가 생겼다고 해보자. 메모리 누수일 수도 있고, 부하가 심한 상황에서 발생하는 레이스 컨디션일 수도 있음.
   - 그래서 특정 노드가 클러스터에서 빠지면, 나머지 노드들이 추가로 부하를 얻게 됨.
   - 부하 관련 이슈이므로 나머지 노드들 역시 같은 이슈를 겪을 가능성이 높아짐.
2. 결함을 제거하는 것이 연쇄 반응을 막을 수 있는 유일한 방법.
3. Bulkhead 패턴처럼 레이어를 여러 개의 풀로 나누는 것이 때때로 도움이 되기도 함.

## Cascading Failures

1. 한 레이어에서 균열이 생기고, 호출부 레이어에도 영향을 미치면서 실패가 점점 증폭되어 전파됨.
2. 예를 들어, DB가 먼저 고장이 나면, 이 DB를 호출하는 애플리케이션들 또한 문제를 겪게 됨. 어떤 문제를 겪게 되는지는 애플리케이션이 문제를 어떻게 다루는지에 따라 달려 있음. 잘못 다루고 있다면, 실패 전파로 이어지는 것.
3. 섣부른 재시도는 호출부의 스레드를 더 낭비하게 할 수도.
4. 오히려, 이러한 실패 전파를 막을 수 있는 가장 효과적인 방법은 Circuit Breaker와 Timeout.

## Users

### TRAFFIC

수용량<sup>capacity</sup>을 벗어나는 수준의 요청이 들어오면 시스템은 어떻게 반응하는가?

> "Capacity" is the maximum throughput your system can sustain under a given workload while maintaining acceptable performance.

#### Heap Memory

1. 메모리는 수용량을 벗어나기 쉬운 대상 중 하나.
2. 인 메모리 세션을 사용하는 경우, 마지막 요청으로부터 세션 타임아웃이 일어나기 까지의 데드 타임도 존재하고, 사용자의 증가에 따라 메모리 사용량도 그대로 늘어나기 때문에 종종 문제가 됨.
3. 사용자에게 OOM 오류가 전달되는 것도 나쁘지만, 최악은 메모리 부족으로 에러 로그도 남지 않는 것.
4. 이를 방지하는 한 가지 방법은 인 메모리 세션을 최대한 가볍게 유지하는 것.
5. 혹은, 메모리가 충분할 때는 많은 데이터를 가지고 있다가, 메모리가 부족해지면 알아서 제거되도록 하는 것도 방법. ([java.lang.ref.SoftReference](https://docs.oracle.com/javase/7/docs/api/java/lang/ref/SoftReference.html)를 소개하고 있음)

```java
MagicBean hugeExpensiveResult = ...;
SoftReference ref = new SoftReference(hugeExpensiveResult);

session.setAttribute(EXPENSIVE_BEAN_HOLDER, ref);
```

#### Off-Heap Memory, Off-Host Memory

1. 사용자 별 메모리를 다루는 또 다른 효과적인 방법은 별도의 프로세스로 관리하는 것.
2. 서버 프로세스의 주소 공간 안에 위치시키는 대신, Memcached, Reids와 같은 독립적인 프로세스에 두는 것.
3. 물론, 트레이드 오프가 존재함. 다름 아닌 크기와 거리(성능). 더 많은 공간을 얻는 대신, 더 먼 거리에서 데이터를 주고 받음.

#### Sockets

1. 서버의 소켓 갯수 또한 트래픽이 무거워질 때 문제가 될 수 있음.
2. OS는 인바운드 연결을 수명이 짧은<sup>ephemeral</sup> 포트에 할당.
3. TCP 패킷 포맷을 들여다 보면, 포트 번호 길이가 16 비트임을 확인할 수 있음.
4. 따라서, 65,535개까지만이 가능. OS별로 다를 수는 있으나 IANA는 49,152에서 65,535를 권장한다고 함.
5. 하지만, 어떤 서버들은 동시에 백만개의 연결을 받아주기도 함.
6. 이것이 가능한 이유는 가상 IP 주소 때문임.
7. OS는 추가 IP 주소들을 동일한 네트워크 인터페이스에 바인딩함.
8. 각 IP 주소는 자신의 고유한 포트 번호 범위를 가지며, 16개의 IP 주소가 있다면 위와 같은 많은 연결들을 받아줄 수 있게 됨.
9. 하지만, 이렇게 많은 연결을 허용하는 것이 쉬운 것은 아님. 애플리케이션에도 변화가 필요하며, 많은 커널 버퍼들이 필요함. OS의 TCP 튜닝 파라미터에 대해 많은 공부가 필요할 것.

#### Closed Sockets

1. 소켓을 여는 것도 문제가 될 수 있지만, 이미 닫힌 소켓 또한 문제가 될 수 있음.
2. 애플리케이션 코드에서 소켓을 닫으면, TCP 스택은 소켓을 두 개의 상태를 거치게 하는데, 그 중의 하나는 TIME_WAIT.
3. 이는 소켓이 새로운 연결에 재사용 되기 전 유예 기간 같은 것이며, bogons에 대한 TCP 방어책 중 하나.
4. bogons란, 비효율적으로 라우팅 되어 늦게 도착하는 방황하는 패킷을 가리킴.
5. 소켓이 너무 빨리 재사용되면, 이렇게 늦게 도착한 패킷이 마치 새로 시작하는 정상적인 패킷 처럼 여겨질 수도 있음.
6. [bogons](https://en.wikipedia.org/wiki/Bogon_filtering)이 실제로 발생하는 문제이긴 하지만, 이슈가 될 가능성은 매우 낮으며, 따라서 TIME_WAIT 인터벌을 낮출 수도 있음.

### EXPENSIVE TO SERVE

1. 단지 읽기만 하고 나가는 사용자에 비해, 실제로 물건을 장바구니에 담고 결제를 하는 등의 연동 포인트나 쓰기를 발생시키는 고객들이 존재. 책에서는 expensive user라고 부름.
2. 수익에 도움이 되는 고객이긴 하지만, 시스템에 부하를 주는 것도 사실. 어떻게 다루는 것이 좋을까.
3. 가장 좋은 방법은 공격적으로 테스트 하는 것.
4. 가장 비용이 큰 트랜잭션을 파악하고, 평소 대비 2~3배의 트랜잭션을 만들 것.
5. 만약, 시스템이 2퍼센트의 전환률을 예상한다면, 4~10퍼센트 정도의 전환률을 테스트 하는 것.

### UNWANTED USERS

1. 이상한, 나쁜 고객들은 존재한다.
2. 쿠키 값을 비워둔 채, 응답을 기다리지 않는 수 십만 개의 요청을 동시에 보낼 수도 있음. 마치 새로운 사용자가 요청을 던지는 것 처럼 보여질 수 있고, 서버에서는 요청 마다 새로운 세션을 생성하기도 함. 또한, 세션 생성 시 '마지막 로그인' 시간 같은 것을 매번 갱신하게 할 수도 있음. 부하가 더 커지는 것.
3. 악의적인 요청들도 만들 수 있음(스크린 스크래퍼). 마치, 경쟁 식료품 가게가 옆 가게에 악의적 손님들을 줄을 세워서, 정상정인 손님들이 가게 안으로 못 들어가게 하는 것 처럼 말이다.
4. 스크린 스크래퍼 같은 것을 막는 방법으로, 네트워크에 이런 요청을 가려내 차단하게 하거나, 법적 조치를 취하기도.

## Blocked Threads

1. 멀티스레딩은 많은 처리를 동시에 할 수 있게 해주었지만, 동시성 오류의 가능성을 가져왔음.
2.  필자가 겪은 대부분의 시스템 장애는 명백한 충돌이라기 보다는, 프로세스는 실행중이지만 프로세스들이 아무 것도 하지는 않는 상태였음.
3. 하지만 사용자 입장에서는 똑같은 문제. 어쨋든 사용자가 아무 것도 할 수 없기 때문임. 비즈니스 스폰서 입장에서는 "Is it generating revenue?"라고만 물을 뿐임.
4. 이 때문에 외부 모니터링과 함께 내부 모니터링도 필요하다고 주장. 목<sup>mock</sup> 클라이언트를 만들어 실제 사용자가 수행하는 트랜잭션들을 주기적으로 확인해 보게 할 수도 있음. 프로세스가 실행중이냐 여부와 상관 없이, 사용자가 겪을 수 있는 문제를 조기에 드러낼 수 있음.
5. 스레드 잠김(잠시 동안의 잠김은 문제 없음. 오히려 자연스러움)은 어려운 문제이고, 테스트로도 발견하기 어려움. 가장 좋은 방법은 신중하게 코드를 작성하는 것. 잘 작성되고 입증된 라이브러리를 사용하는 것도 좋음.
6. 여러 가지 이유로 도메인 객체에 synchronize를 사용하는 것도 반대. 대신, 도메인 객체를 불변으로 만들라고 권장함. 질의와 렌더링에 사용하는 것. 상태를 변경해야 한다면, 커맨드 객체에게 위임. CQRS라고도 불림.

#### SPOT THE BLOCKING

```java
String key = (String) request.getParameteR(PARAM_ITEM_SKU);
Availability avl = globalObjectCache.get(key);
```

1. 위 코드에서 블럭킹 호출을 찾을 수 있겠는가?
2. `globalObjectCache`가 동기화가 있을만한 지점이라고 추측했을지도 모르지만, 여기서 중요한 것은 호출 코드에서는 어디가 블럭킹 지점인지 결코 알 수 없다는 것.
3. 자바에서는 synchronized 메소드를 unsynchronized로 바꾸기 위해 클래스를 상속할 수도 있음. 리스코프 치환 원칙에 위배되기도 함.

```java
public class GlobalObjectCache {
    // ...
    public synchronized Object get(String id) {
        Object obj = items.get(id);
        if (obj == null) {
            obj = create(id);
            items.put(id, obj);
        }
    }
    // ...
}
```

4. 어쨌든 `GlobalObjectCache#get`에는 synchronized가 걸려 있음.
5. 이를 사용하는 시스템에서는 재고 관리가 필요했음. 재고 정보는 원격 호출로 가져오고, 15분 단위로 원격 시스템에서 재고 수치를 갱신.
6. 재고 호출량이 많기 때문에, 호출자는 캐싱을 도입하기로 함.
7. 캐싱 도입을 위해 `GlobalObjectCache`를 상속하는 `RemoteAvailabilityCache`를 만들고, create 부분을 원격 호출하는 코드로 대체.
8. 기능적으로 문제가 없었으나 부하가 심한 경우 원격 호출이 대기하게 됐고, synchronized와의 조합으로 수 많은 호출부가 대기하게 됨.
9. 결과적으로 전체 사이트가 다운 됨. 단지, 원격 재고 시스템이 안 된다는 이유 때문에 말이다. 재고를 불러올 수 없다고 전체 시스템이 마비되어야 할까?

#### LIBRARIES

1. 라이브러리는 스레드 잠김의 단골 손님. 오픈소스이건 벤더 코드이건.
2. 많은 라이브러리들은 자신의 리소스 풀링을 위해 마치 서비스 클라이언트 처럼 동작함. 이것이 영원히 스레드가 잠기는 문제의 원인이 됨.
3. 또한, 이런 라이브러리들은 자신들의 실패 모드에 대한 설정을 제공하지 않음.
4. 여기서 벤더 코드에 대한 비판이 또 나옴. 기록은 생략.
5. 라이브러리가 깨지기 쉽다면, 요청을 다루는 스레드를 우리가 보호할 수 있어야 함.
6. 그렇지 않다면 적어도 퓨처를 반환하는 래퍼 클래스로 라이브러리를 감싸는 것이 좋음. 그리고 이 래퍼 클래스들을 사용할 수 있는 스레드 풀을 관리하라는 이야기. 타임아웃도 래퍼 클래스를 통해 제공하고 말이다. Hystrix의 [`execution.isolation.strategy`](https://github.com/Netflix/Hystrix/wiki/configuration#executionisolationstrategy)를 같이 보면 더 좋을 듯.
7. 이런 블럭 스레드는 통합 지점에서 주로 발견되며, 연쇄 반응으로 이어지기 쉽상. 또한 피드백 루프를 만들며 사소한 문제가 전체 장애로 확장되기도.

#### REMEMBER THIS

원래 이 항목은 기록하지 않았는데, 아래 내용이 인상 깊어서 특별히 기록함.

> All manner of problems can lurk in the shadows of third-party code. Be very wary. Test it yourself. Whenever possible, acquire and investigate the code for surprises and failure modes. You might also prefer open source libraries to closed source for this very reason.

## Self-Denial Attacks

1. Self-Denial Attack을 어떻게 번역해야 할지 모르겠음.
2. 어쨌든 책에서 소개하는 이 단어의 정의는 다음과 같음.

> A self-denial attack describes any situation in which the system-or the extended system that includes humans-consipires against itself.

3. 스스로를 망가뜨리는 상황을 이야기하는 것이고, 대량의 트래픽이 몰릴 수 있게 마케팅을 하는 등의 행위를 가리킴.
4. 트래픽이 몰리는 경우를 대비하는 방법으로 (어떻게 보면 당연한) "shared-nothing" 아키텍처 구성도 언급함. 다소 뜬금 없긴 하지만, 대량 트래픽이 몰리는 경우 공유 자원에 의해 잘못된 잠금을 경험했기 때문에 언급하는 것으로 보임.
5. 또한, 하드웨어 로드 밸런싱을 구성하고, 요청이 몰리는 시스템의 나머지에 대해서는 정상적으로 응답하게 할 수도 있음. 미리 이벤트 상품 전용 서버를 구축할 수도 있음.
6. 오토 스케일링 시에는 "pre-autoscale"을 권장한다는 이야기도.
7. 교육과 훈련, 커뮤니케이션의 중요성도 함께 언급. (별 것 아닌 것 같지만 제일 효율적인 수단이라고 생각함)

