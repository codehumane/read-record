# Living in Production

- feature complete != production ready
- crash, hang, lose data, violate privacy, lose money, crazy real uses, globe-spanning taffic, virus writing mobs, …
- 최선의 계획을 세우더라도 나쁜 일이 일어난다는 것을 받아들여야 함. 따라서, 할 수 있는 것들을 최대한 하되, 어떤 심각한 상황에서도 전체 시스템이 회복될 수 있어야 함.

## Aiming for the Right Target

- "고객의 첫 번째와 마지막 이름은 필수고, 중간은 선택이에요"와 같은 테스트를 통과하기 위함이 아님.
- 대신, "design for production"

## The scope of the Challenge

- 사용자는 늘어나고, 더 높은 수준의 가용성이 요구됨.
- 빌드 비용이 저렴하고, 사용자에게 유용하고, 운영 비용이 적은 소프트웨어를 빠르게 만들어내야 함.
- 조그마한 워드프레스에 적절한 설계는 대규모 확장과, 트랜잭션, 분산 시스템 등의 요구에 실패할 것.

## A Million Dollars Here, a Million Dollars There

- 설계와 아키텍처 결정은 또한 재정적 결정.
- 이런 결정들은 구현 비용과 더불어 후속 비용(가용성이나 배포 비용 등의 운영을 가리키는 듯)도 함께 고려해야 함.
- 기술적 그리고 재정적 관점은 이 책에서 반복적으로 다루는 중요한 테마.

## Use the Force

- "Use the Force"가 무슨 말인가 했더니, 스타워즈에 나오는, 앞을 내다보라는 식의 말인 것 같다.
- 저자는 열성적인 애자일 지지자이긴 하지만, 초기 결정의 중요성에 대해 말하고 있음.
- 이 결정이 시스템의 궁극적 모습에 지대한 영향을 미치기도 하고, 때로는 돌이킬 수 없기도 함.
- 앞으로 책에서, 어떤 문제에 대한 대안을 소개하고, 이들이 선택된 이후에 어떤 영향을 미치는지 살펴본다고 함. 궁금.

## Pragmatic Architecture

- 저자는 아키텍트를 2개로 분류하는데, 하나는 상아탑<sup>ivory towel</sup>이고, 다른 하나는 실용주의.
- 높은 추상화를 추구하기 보다는 현실적 문제를 다룸. 메모리 사용량, CPU 요건, 대역폭, 하이퍼스레딩과 CPU 바인딩의 이점과 단점 등을 논의.
- 특별한 이야기는 아님. 개인적으로는 지면이 아까운..

# Case Study: The Exception That Grounded an Airline

- 정기적인 DB 유지보수가 있었고,
- 이 때, A라는 DB로부터 B라는 DB로 페일오버가 예정됨.
- 서비스에 이상이 없는지를 확인할 수 있는 모니터링과 함께,
- 무중단 DB 페일오버를 수동으로 진행.
- 문제 없이 완료 후 작업은 모두 끝남.
- 하지만 몇 시간 후 항공사 시스템에 전면 장애가 발생.
- 장애 발생 시의 즉각적인 대응과 포스트 모텀 등을 이야기 한 뒤(이런 부분들이 잼있었음),
- 문제의 원인이 된 코드도 보여줌. CF라는 시스템은 아래의 코드만으로 이뤄진 애플리케이션이 실행되고 있었다고 함.

```java
public class FlightSearch implements SessionBean {

    private MonitoredDataSource connectionPool;

    public List lookupByCity(...) throws SQLException, RemoteException {
        Connection conn = null;
        Statement stmt = null;

        try {
            conn = connectionPool.getConnection();
            stmt = conn.createStatement();

            // ...
        } finally {
            if (stmt != null) {
                stmt.close();
            }
            if (conn != null) {
                conn.close();
            }
    }
}
```

- `stmt.close()`가 SQLException을 던지기 때문.
- 데이터베이스의 페일오버 시 연결이 끊겼고, 이 때 `stmt.close()`의 호출이 예외를 발생시켰으며, 이로 인해 커넥션이 종료되지 않고, 리소스가 누수되어서 발생한 문제.

# Stabilize Your System

1. 엔터프라이즈 소프트웨어는 냉소적이어야 함.
    - 나쁜 것이 일어날 것을 예상하고, 그것이 일어났을 때 놀라지 않는 것.
    - 스스로를 또한 믿지 않기 때문에 장애 시의 대비책도 마련.
    - 다른 시스템과 너무 밀접<sup>intimate</sup>해지는 것을 거부. 다치는 것을 염려하기 때문.
    - 앞선 항공사 사례에서의 예외는 충분히 회의적이지 않았음.
2. 낮은 안정성은 많은 실질적 비용을 초래. 수익은 물론, 평판도 마찬가지.
3. 좋은 안정성에 꼭 많은 비용이 들일 필요는 없음.
    - 아키텍처나 설계, 저수준 구현 시 많은 안정성을 위한 레버리지 포인트들이 존재.
    - 이 레버리지는 기능적 요구사항과 상충되는 길이 아니며,
    - 안정적이지 못한 것과 안정적인 것을 만드는데 들어가는 시간은 동일하다고.
    - (하지만 갑자기 자본론이 떠오름. 아쉬움)

## Defining Stability

대부분의 사람들은 "안정성<sup>stability</sup>"을 아래와 같이 정의한다고 함.

> 강건한 시스템은 일시적 충격<sup>impulse</sup>이나, 지속적인 스트레스<sup>stress</sup>, 컴포넌트의 실패에 상관 없이, 트랜잭션 처리를 지속함.

여기서의 트랜잭션과 시스템의 의미는 각각 다음과 같음.

- 트랜잭션: 시스템에 의해 처리되는 일의 단위를 추상화한 것. DB 트랜잭션 X. "customer places order"와 같이 다른 시스템(카드사 등)과의 통합이 포함될 수도.
- 시스템: 사용자의 트랜잭션을 처리하기 위한 하드웨어, 애플리케이션, 서비스의 상호 의존적이고 완전한 집합.

## Extending Your Life Span

1. 시스템 수명에 대한 주요 위험 요소는 메모리 누수와 데이터 성장이라고 함.
2. 이 둘은 모두 테스트 기간에는 잡히기 어려운 것들. (주로 긴 시간을 두고 운영할 때 생기는 문제이기 때문)
3. 테스트에 관해서는 머피의 법칙을 따르자. 테스트 안 한 것이 문제가 됨. 42시간이 지나야 생기는 메모리 누수, 자정이 지나야 생기는 충돌 문제 등.
4. 그런데 이런 장기적(?) 버그는 어떻게 찾을 수 있을까.
5. 개발 장비를 하나 마련해서 JMeter, Marathon 등으로 장기 버그를 테스트. 심한 부하를 주기 보다는, 적정한 양의 요청을 지속적으로 보내고, 이따금 일정 기간 동안에는 적은 양의 요청을 보내게 하라(커넥션 풀이나 방화벽 시간 제한 등의 문제를 잡을 수 있다고 함).
6. 돈이 문제가 된다면 적어도 중요한 부분만이라도 하라.
7. 이런 테스트가 없다면, 프로덕션 환경 = 장기 테스트 환경

## Failure Modes

1. 갑작스런 충격이나 과도한 긴장<sup>strain</sup>(스트레스가 가해진 모습을 가리킴)은 재앙적 실패<sup>catastrophic failure</sup>를 불러올 수 있음.
2. 일부 컴포넌트에 장애가 생기고, 이것에 의존하는 다른 컴포넌트에 급속도로 장애가 전파되는 것을 가리킴.
3. 다양한 고장 모드는 반드시 일어남. 충격을 수용하고 나머지 시스템을 보호하는 안전한 고장 모드를 만들어야 함.
4. 이런 종류의 자가 보호가 전체 시스템의 회복 탄력성<sup>resilience</sup>을 결정.
5. Chiles라는 사람은 이를 가리켜 "crackstoppers"라고 부름.

## Stopping Crack Propagation

고장 모드 설계는 항공사 사례에 적용 가능함. SQLException를 부적절하게 핸들링 했던 것이 원인인데, 이를 막을 수 있었던 지점을 저수준부터 고수준까지 소개. 먼저, DB 연결 설정부터.

1. 가용한 풀이 없으면 요청 스레드를 막도록 설정되어 있었기 때문에, 결국 요청을 처리하는 모든 스레드를 가두게 됨.
2. 자원이 고갈되면 더 많은 커넥션을 생성하도록 설정할 수도 있었을 것. (새로 바뀐 DB에 대해 새로운 커넥션을 맺을 수 있었을 것)
3. 또는 호출자를 영원히 멈추게 하는 대신, 제한된 시간 동안만 막도록 설정할 수도 있었을 것.
4. 참고로, 아래 내용은 HikariCP의 `maximumPoolSize`에 대한 설명. 더불어, 이런 글([Hikari, About Pool Sizing](https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing))도 있음. 예전에는 못 봤던 문서.

> "This property controls the maximum size that the pool is allowed to reach, including both idle and in-use connections. Basically this value will determine the maximum number of actual connections to the database backend. A reasonable value for this is best determined by your execution environment. When the pool reaches the size, and no idel connections are available, calls to getConnection() will block for up to `connectionTimeout` milliseconds before timing out."

다음으로, CF가 다른 애플리케이션을 호출할 때 RMI를 사용한 것에 대해.

1. RMI는 기본적으로 타임아웃이 없음. 호출이 블럭되면 영원히 대기.
2. RMI 소켓에 타임아웃을 설정하는 것이 좋았을 것.
3. 혹은, HTTP 요청을 타임아웃과 함께 사용.
4. 블럭된 스레드를 클라이언트가 버리는 것도 방법.

좀 더 큰 수준에서 본다면.

1. CF 서버를 2개 이상의 서비스 그룹으로 나누는 것도 방법.
2. 모든 그룹이 여전히 다 죽을 수도 있지만, 항상 그런 것은 아님.

이보다 더 큰 수준의 아키텍처 이슈로 본다면.

1. CF에서 요청/응답 메시지 큐를 사용할 수도 있음.
2. 혹은 튜플 스페이스<sup>tuple space</sup>에서 검색 조건에 맞는 항공편을 찾을 수도.
3. 아키텍처의 결합도가 높아질수록, 오류가 전파될 가능성은 높아짐.
4. 반대로 말하면, 아키텍처 결합도가 낮을 수록 충격을 흡수함. 에러를 증폭시키는 대신 줄여주기도.

## Chain of Failure

1. 하나의 작은 이슈가 다른 이슈를 낳고, 그리고 이로 인해 또 다른 이슈가 생기고, ...
2. 이런 일련의 사건들이 모두 똑같이 일어날 확률은 매우 낮음. 그러나 각각은 독립사건.
3. 그러나, 사건의 조합은 독립적이지 않음. 특정 지점이나 레이어의 장애는 이에 의존하는 다른 지점의 장애를 일으킬 가능성이 큼.
4. 예컨대, DB가 느려지면 애플리케이션 서버들의 메모리는 고갈될 가능성이 높음.
5. 3가지 용어 정의를 잠깐 하고 가면 아래와 같음.

```
Fault: 소프트웨어의 내부 상태를 비정상적으로 만드는 상황. 지연 버그, 체크되지 않은 경계 조건이나 외부 인터페이스 등에 의한 것.
Error: 비정상적인 행위가 가시적인 것. 트레이딩 시스템이 갑자기 100억 달러를 사들인다거나 하는 것.
Failure: 응답하지 않는 시스템. 
```

6. 실패<sup>fault</sup>는 틈을 열고, 에러가 되며, 에러는 장애가 됨.
7. 당연하게도, 높은 수준의 결합도를 가진 복잡한 시스템은 에러로 이어질 수 있는 실패 전파의 경로가 많음.
8. 가능한 실패에 대해 미리 준비할 수 있는 한 가지 방법은 모든 외부 요청, I/O, 리소스 사용을 살피고, 잘못된 수 있는 경우를 따져보는 것.

```
초기 연결이 맺어지지 않는다면?
연결을 맺는데 10분이 걸린다면?
연결은 맺었는데, 다시 끊어진다면?
연결을 맺었는데, 응답이 오지 않는다면?
질의 응답이 오는데 2분이 걸린다면?
10,000개의 요청이 동시에 들어온다면?
`SQLException` 에러 메시지를 로깅하는데 디스크가 꽉 차있다면?
```

9. 실패는 반드시 발생하며, 모든 것을 예방할 수는 없음.
10. 그리고 이 실패가 에러가 되지 않도록 막음과 동시에 실패나 에러를 감수할 것인지 결정도 해야함.

# Stability Antipatterns

## Integration Points

1. 저자는 1996년 이래로 단일 모드로 된 웹사이트를 본 적이 없다고 함.
2. 모든 프로젝트는 통합된 프로젝트였으며, [나비](https://www.safaribooksonline.com/library/view/release-it-2nd/9781680504552/images/stability/butterfly.png)나 [거미](https://www.safaribooksonline.com/library/view/release-it-2nd/9781680504552/images/stability/spiderweb_orderly.png) 형태 중 하나.
3. 이런 연결들은 모두 통합 지점이며, 각각은 모두 시스템을 붕괴시킬 수 있는 요소.
4. 책에서는 통합 지점을 가리켜 "number-one killer of systems"라고 표현하기도 함.
5. 모든 소켓, 프로세스, 파이프, 원격 프로시저 호출, 데이터베이스 연결 등이 여기에 해당.
6. 뒤이어서, 통합 지점이 문제가 될 수 있는 몇 가지 상황과 각각에 대한 대처 방안에 대해 살펴봄.

### SOCKET-BASED PROTOCOLS

1. 많은 상위 수준의 통합 프로토콜은 소켓 위에서 실행되며, 프로토콜들은 소켓이 문제가 되는 경우를 위한 실패 모드를 지원.
2. 가장 단순한 실패 모드는 원격 시스템이 연결을 거부할 때 발생. 하지만, 연결 거부는 주로 문제가 되지 않음. 많은 언어들이 API를 통해 연결 실패가 발생할 수 있음을 잘 알려주기 때문.
3. 한 가지 주의할 것은 연결할 수 없음을 발견하는 데 오랜 시간이 걸릴 수 있다는 것.
4. 잠시, TCP/IP 네트워킹에 대해 소개하고 넘어감.

> 네트워크 연결을 표현하는 많은 그림들은 박스와 화살표를 사용함. 하지만, 이는 추상화한 것을 다시 또 추상화한 것. 네트워크 "연결"은 논리적 언어. 네트워크 상에서 우리가 볼 수 있는 것은 단지 패킷(물론, 패킷 또한 추상화 된 것. 전기와 광자, ...). 이들 패킷은 TCP/IP의 IP에 해당. TCP는 불연속적인 패킷들의 주고 받음을 어떻게 연속적인 연결로 보이게 할 것인가에 대한 약속.
> 
> TCP는 연결을 열기 위해, "three-way handshake"를 사용. 호출자가 SYN 패킷을 원격 서버의 포트에 전달. 아무도 포트에 대해 리스닝하고 있지 않다면, 즉각 TCP "reset" 응답을 반환. 호출 애플리케이션은 예외 또는 잘못된 응답 값을 받게 됨. 이 과정은 매우 짧은 시간 내에 일어나며, 같은 스위치로 연결된 장비라면 10ms 이하로 소요. 목적지 포트에 대해 리스닝하고 있는 애플리케이션이 있다면, 원격 서버는 SYN/ACK 패킷(연결을 받을 준비가 됐다는 의미로)을 응답. 이 응답을 받은 호출자는 다시 ACK를 전송함. 이 세개의 패킷들이 바로 "연결"을 만들어 냄. 애플리케이션들은 이제 데이터를 서로 주고 받을 수 있음.

5. 포트는 "리스닝 큐"를 가지고 있음. 이는 얼마나 많은 대기 연결(SYN은 보내졌지만, SYN/ACK를 응답하지 않은)을 네트워크 스택에 허용할지를 정의. 리스닝 큐가 꽉 차면, 이후의 연결 시도는 재빨리 거부됨. 리스닝 큐는 최악의 장소.
6. 소켓이 상태를 부분적으로 형성하고 있는 동안, open 상태의 스레드는 OS 커널 안에서 대기하게 됨. 원격 애플리케이션이 연결을 받아들이거나, 커넥션이 타임아웃이 될 때까지.
7. 연결도 되고 요청도 보냈지만, 원격 서버가 요청을 읽어들이거나 응답을 반환하는 데 오랜 시간이 걸릴 수도 있음. read 요청(open 상태의 스레드와 마찬가지로) 또한 대기 상태가 될 수 있음.
8. 네트워크 실패의 종류는 2가지. 빠르거나 느리거나. 빠른 실패는 "Connection refused" 같은 예외를 즉각 일으킴. 느린 실패(중단된 ACK 같은)는 예외를 던지기까지 몇 분 동안 스레드를 대기시킬 수 있음. 대기된 스레드는 다른 트랜잭션을 처리할 수 없고, 전체 가용 자원은 줄어듦. 만약, 모든 스레드가 대기하게 되면, 서버는 결국 중단됨.

> "Clearly, a slow response is a lot worse than no response."

### THE 5 A.M. PROBLEM

1. 매일 아침 5시만 되면 행이 걸렸고, 재시작으로 항상 문제가 해결됨.
2. 이 문제가 생기고 나서 3일이 되는 날 스레드 덤프를 생성.
3. 인스턴스는 살아 있었지만, 요청을 처리하는 모든 스레드가 Oracle JDBC 라이브러리 부근에서 블럭 상태. 특히 OCI 호출부 안에서.
4. synchronized 메서드를 진입하려고 대기하는 스레드를 제외하면, 활성화 된 스레드들은 모두 저수준의 소켓 읽기나 쓰기 호출에 사용되고 있는 것으로 보였음.
5. 다음 단계는 tcpdump 또는 ethereal(현재는 Wireshark라고 불리는).
6. 이 도구를 통해 살펴보니, 애플리케이션 서버에서 일부 패킷들이 데이터베이스 서버로 전송됐지만, 응답이 없는 상태였음.
7. 하지만, 모니터링 도구를 통해 살펴보면 데이터베이스는 살아 있으며 건강하다고 표시됨.
8. 블럭 상태의 락은 없었으며, 큐 갯수는 0개였고, I/O 비율은 정말 낮았음.
9. 그러고 나서 하루가 지나고 문제는 어김 없이 다시 발생.
10. 이번에는 데이터베이스 네트워크 트래픽을 살펴볼 수 있었음.
11. 그런데 트래픽이 전혀 없었음. 이것이 큰 단서.
12. 앞서 소켓 연결의 추상화를 언급했었음. 양쪽의 컴퓨터 메모리에 소켓이 연결 상태라고 표시되어 있으면 그게 곧 연결인 것. 하루 종일 1개의 패킷도 보내지 않는 중이라고 하더라도, 라우트가 변경되더라도, 물리적 링크가 다시 연결되더라도 말이다.
13. 방화벽은 특수화 된 라우터에 지나지 않음.
14. 각 방화벽 내부에는 접근 제어 목록 집합이 정의되어 있음.
15. SYN 패킷이 들어오면 방화벽은 허용하거나(목적지로 전달), 거부하거나(TCP 리셋 패킷을 다시 돌려줌), 무시하거나(응답 없이 패킷을 버림) 중 하나를 취함.
16. 연결이 허용되면 방화벽은 이 엔트리를 내부 테이블에 기록하고, 엔드포인트가 일치한 이후 패킷들에 대해서는 요청을 라우팅해 줌.
17. 이 방화벽 이야기가 아침 5시 문제와 무슨 관계가 있을까?
18. 핵심은 방화벽의 연결 허용 기간이 유한하다는 것. TCP는 무한한 기간의 연결을 허용하더라도 말이다.
19. 마지막 패킷 시간으로부터 많은 시간이 지났다면, 이 연결을 죽었다고 간주하고 이후에 들어오는 패킷을 버림(무시).
20. 라우터로써, 방화벽은 ICMP 리셋을 전달할 수도 있었으나, 악의적인 공격에 의한 ICMP 트래픽을 억제하기 위해 설정되어 있었음.
21. 결국, 반쯤 열린 소켓은 읽기나 쓰기 시도시 TCP 리셋이나 에러를 받을 수 없었음. 단지, ACK를 기다리고 있을 뿐.
22. JDBC 연결을 사용하기 전에 "SELECT SYSDATE FROM DUAL" 같은 SQL로 유효성을 검증할 수도 있으나, 이 또한 스레드를 행 걸리게 하는 일일 뿐.
23. 대신에 오라클의 dead connection detection을 사용. 이 자체의 기능이 필요했다기 보다, 단지 주기적으로 클라이언트에게 PING 요청을 보내게 함으로써, 방화벽에 마지막 패킷 시간을 계속 최신으로 유지하기 위함.
24. 여기서의 교훈은 추상화된 수준에서 해결되지 않는 문제들이 있다는 것. 때로는 두 단계 정도 아래로 내려와 현실을 마주해야 할 필요도 있음.

### HTTP PROTOCOLS

1. HTTP 기반의 프로토콜은 소켓을 사용함. 따라서, 앞서 언급했던 문제들에 취약.
2. 여기에 HTTP 자체의 이슈들도 더해짐. 예컨대, 아래와 같은 것들이 있음.
   - 수신자가 TCP 커넥션 연결을 받아들였지만, HTTP 요청에 대한 응답을 하지 않음.
   - 연결은 받아들였지만, 요청을 읽어들이지 못할 수도 있음. 요청 바디가 너무 큰 경우, 수신자의 TCP 윈도우를 꽉 차게 하고, 호출자의 TCP 버퍼도 차게 되면서, 소켓의 쓰기가 블럭될 수 있음.
   - 호출자가 반환한 응답 상태를 호출자가 다루는지 모를 수 있음.
   - 수신자가 반환한 컨텐츠 타입을 호출자가 이해하지 못할 수 있음. 예를 들어, JSON 요청을 했는데 404 에러 HTML 페이지가 반환된다거나.
   - 수신자가 JSON을 응답한다고 하면서 실제로는 평문을 반환할 수도 있음.
3. 세부적인 제어가 가능한 클라이언트 라이브러리를 사용하라. (커넥션과 읽기 타임아웃 등이 제공되는)
4. 응답을 바로 도메인 객체로 매핑하려는 라이브러리는 쓰지 말아라. 기대를 충족하는 응답인지를 먼저 확인할 수 있어야 한다.

### VENDOR API LIBRARIES

그냥, 왠만해서는 쓰지 말라는 이야기.

### COUNTERING INTEGRATION POINT PROBLEMS

1. 통합이 없는 시스템은 드물고, 대부분 쓸모도 없음.
2. 통합 지점을 어떻게 안전하게 만들 수 있을까?
3. 가장 효과적인 안정성 패턴은 Circuit Breaker와 Decoupling Middleware(뒤에서 다루는 내용들).
4. 테스팅 또한 도움이 됨.
    - 냉소적인 소프트웨어는 형태나 기능 위반(잘못된 형태의 헤더나 비정상적인 연결 종료 등)을 다룰 수 있어야 하고,
    - 이를 확인하기 위해서 Test Harness가 도움이 됨.

### REMEMBER THIS

1. Beware this necessary evil: 모든 통합 지점은 결국엔 어떤 식으로든 실패함.
2. Prepare for the many forms of failure: 통합 지점 실패는 다양한 형태를 띰. 다양한 네트워크 오류부터 문법 에러까지. 그리고 약속된 프로토콜을 통해 에러가 오는 감사한 경우도 없을 것.
3. Know when to open up abstractions: 통합 지점 실패를 디버깅할 때는 종종 저수준을 살펴야 하기도. 패킷 스니퍼나 네트워크 진달 도구가 도움이 됨.
4. Failure propagate quickly: 코드가 충분히 방어적이지 않다면, 원격 시스템의 실패는 보통 실패 전파로 이어짐.
5. Apply patterns to avert integration point problems: Circuit Breaker, Timeouts, Decoupling Middleware, Handshaking 등이 도움이 될 것.

## Chain Reactions

1. 스케일 아웃을 취하고 있다고 하더라도, 부하 관련 충돌이나 자원 누수와 같은 결함은 연쇄 반응으로 이어질 수 있음.
   - 예를 들어, 클러스터에서 특정 노드가 부하로 인해 문제가 생겼다고 해보자. 메모리 누수일 수도 있고, 부하가 심한 상황에서 발생하는 레이스 컨디션일 수도 있음.
   - 그래서 특정 노드가 클러스터에서 빠지면, 나머지 노드들이 추가로 부하를 얻게 됨.
   - 부하 관련 이슈이므로 나머지 노드들 역시 같은 이슈를 겪을 가능성이 높아짐.
2. 결함을 제거하는 것이 연쇄 반응을 막을 수 있는 유일한 방법.
3. Bulkhead 패턴처럼 레이어를 여러 개의 풀로 나누는 것이 때때로 도움이 되기도 함.

