# 알고리즘 도감

- Algorithms: Explained & Animated (그림으로 배우는 알고리즘 26)
- 이시다 모리테루, 미야자키 쇼이치 지음.
- 간단히 개념들을 정리할 때 유용.

# 데이터 구조

## 리스트

- 데이터를 일직선으로 나열한 형태.
- 배열과 달리, 각 데이터들이 연속된 위치에 저장되지 않음.
- 대신, 포인터로 연결된, 순차 접근<sup>sequential access</sup>.
- 원하는 데이터를 찾아 가는데 O(N)의 시간이 걸리지만,
- 추가와 삭제에는 O(1)의 시간이 소요.
- 원형 리스트나 양방향 리스트로 변형되기도 함.

## 배열

- 데이터를 일직선으로 나열한 형태.
- 리스트와 달리, 각 데이터들이 연속된 위치에 저장됨.
- 따라서, 포인터가 필요 없고, 임의 접근<sup>random access</sup>으로,
- 원하는 데이터에 O(1)의 시간으로 접근 가능.
- 추가와 삭제는 O(N).

## 스택

- 마찬가지로, 데이터를 일직선으로 나열.
- 하지만, LIFO로 데이터를 추가/삭제/접근함.
- 항상 최신 데이터만 접근하는 경우에 유리.
- 자주 보는 괄호 퀴즈나, 깊이 우선 탐색에 사용.

## 큐

- 대기 행렬이라고도 불림.
- 스택과 달리 FIFO.
- 너비 우선 탐색 등에 사용.

## 해시 테이블

- 해시 함수, 리스트, 배열을 사용.
- 일단, 버켓<sup>buckets</sup>(또는 슬롯<sup>slots</sup>)을 생성. 배열과 같은 형태라고 보면 됨.
- 그리고 나서, 키를 해싱. 해싱한 값을 버켓의 크기로 mod 연산.
- 그 결과 값을 버켓의 인덱스로 하여 저장.
- 만약, 충돌(키는 다른데, 해싱의 결과가 같음)이 발생하면,
- 해당 인덱스의 버켓에 리스트로 데이터를 연결.
- 배열의 크기가 너무 작으면 충돌이 잦고, 그렇다고 너무 크면 빈 버켓이 많아져 낭비가 됨.

## 힙

- 그래프의 트리 구조 중 하나.
- 작은 값이 맨 위에 위치하고, 부모 노드의 숫자는 반드시 자식의 것 보다 큼.
- 이를 위해, 노드 추가 시, 맨 아래층 왼쪽부터 채우되, 만약 부모의 값보다 작으면 부모와 자리를 교체.
- 만약, 가장 작은 노드인 루트가 추출되면, 맨 아래층 오른쪽에 있는 노드를 로트로 이동시킴.
- 그리고 자신보다 작은 자식 노드가 있으면 자리를 교체. 자신보다 작은 자식 노드가 없을 때까지 반복.
- 따라서, 최소값 추출에는 O(1) 시간만 소요되고, 이런 특성 때문에 우선순위 큐 구현에 사용됨.
- 데이터 추가와 삭제로 인해 힙 재구축 시에는 O(log n)이 소요.

## 이진 탐색 트리

- 힙과 마찬가지로, 그래프의 트리 구조 중 하나.
- 첫 번째 특성 ― 모든 노드는 왼쪽 가지에 포함되는 어떤 숫자보다도 큰 숫자가 됨.
- 두 번째 특성 ― 모든 노드는 그 노드의 오른쪽 가지에 포함되는 어떤 숫자보다 작은 숫자가 됨.
- 따라서, 왼쪽 가지만을 따라가다 보면 최솟값을, 오른쪽 가지만을 따라가다 보면 최댓값을 얻게 됨.
- 값 추가 ― 루트 노드부터 아래로 비교해 가며 위치를 찾아감.
- 값 삭제 ― 삭제한 노드의 왼쪽 가지에서 최댓값을 가진 노드를 찾고, 삭제한 노드 자리에 위치시킴.
- 값 접근 ― 루트 노드부터 아래로 비교해 가며 찾아감. 비교 노드 값이 크면 왼쪽 가지로, 작으면 오른쪽 가지로 이동.
- 트리가 어느 정도 균형 잡혀 있다면 O(log n)이 소요되지만, 한쪽으로 치우쳐 있다면 O(n)이 소요될 수 있음.

# 정렬

주어진 값을 순서대로 나열하는 것. 데이터가 많을 수록 이런 정렬 알고리즘의 효율은 중요할 것.

## [bubble sort](https://en.wikipedia.org/wiki/Bubble_sort)

- 가장 오른쪽 값부터 시작해서 왼쪽 값보다 작으면 왼쪽으로 이동.
- 연산 횟수는 (n-1) + (n-2) + ... + 1 = n^2/2
- O(n^2)

## [selection sort](https://en.wikipedia.org/wiki/Selection_sort)

- 수열 중 최솟값 검색해서 가장 왼쪽부터 채워나감.
- (n-1) + (n-2) + ... + 1 = n^2/2
- O(n^2)

## [insertion sort](https://en.wikipedia.org/wiki/Insertion_sort)

- 가장 왼쪽 값부터 시작해서, 자신의 왼쪽 수열 중에 자신이 들어갈 위치를 결정.
- 1 + 2 + ... (n-2) + (n-1) = n^2/2
- O(n^2)

## [heap sort](https://en.wikipedia.org/wiki/Heapsort)

- 내림차순 힙을 구성하고, 루트를 추출. 이를 반복.
- log(n) + log(n-1) + … + log2
- O(n log n)

## [merge sort](https://en.wikipedia.org/wiki/Merge_sort)

- 좌우 분할을 재귀적으로 반복. 나눌 만큼 나눈 뒤 병합을 반복.
- 시간 복잡도 구하기는 [예전에 작성한 글](http://codehumane.github.io/2017/11/11/%EB%B3%91%ED%95%A9%EC%A0%95%EB%A0%AC-%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84-%EA%B5%AC%ED%95%98%EA%B8%B0/) 참고.
- O(n log n)

## [quick sort](https://en.wikipedia.org/wiki/Quicksort)

- 임의의 pivot을 정하고 좌측에는 pivot 보다 작은 값을, 우측에는 큰 값을 둠. 둘로 나눠진 수열에 대해서 재귀 반복.
- 시간 복잡도는 병합 정렬의 것을 구하듯 구하면 됨. O(n log n) 소요.

