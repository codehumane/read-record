# Software Engineering at Google

# Thesis

# 1. What is Software Engineering?

프로그래밍과 소프트웨어 엔지니어링의 3가지 중요한 차이.

1. 시간
   - 수명이 길어질수록 변경이 많음.
   - 비즈니스, OS, 하드웨어, 언어 버전 등.
   - 이에 대응할 수 있는 것이 중요해짐.
   - 수명이 짧은 코드는 단지 프로그래밍 문제에 가까움.
2. 스케일
   - 프로그래밍 작업은 보통 개인의 작업.
   - 소프트웨어 엔지니어링은 팀의 노력.
   - 팀 협업은 개인 프로그래밍에 없던 여러 가지 새로운 문제를 안겨줌.
   - 하지만 혼자할 때에 비해, 좋은 시스템을 만들 가능성이 큼.
   - 제품, 조직, 개발 워크플로우의 규모가 커짐에 따른 비용을 잘 유지하고 관리해야 함.
3. 트레이드 오프
   - 종종 부정확한 가치 메트릭을 기반으로,
   - 상위 수준의 이해관계 결과물을 고려하며,
   - 여러 길 사이의 트레이드 오프를 고려한 복잡한 결정을 내려야 함.

## Time and Change

- 모바일 앱이나 스타트업의 코드 수명은 비교적 짧음.
- 하지만 구글 검색이나 Apache HTTP 프로젝트의 수명은 예측할 수 없음.
- 내부적으로는 indefinitely로 간주한다고 함. 
- 이런 수명이 긴 프로젝트에서는 업그레이드 문제가 중요.
- 이런 업그레이드를 고려하지 않다가 한 번에 업그레이드 하려는 경우 그 비용은 상당.
- 이 비용을 겪고 나면 후속 업그레이드도 크다고 느껴, 코드를 재작성하거나 아예 업그레이드 자체를 피하기도.
- 하지만 첫 번째 큰 업그레이드 이후에도 지속적으로 나아가는 것이 프로젝트의 장기 유지가능성의 핵심.
- 물론, 업그레이드가 제공하는 가치와 비용, 그리고 프로젝트의 기대 수명을 같이 고려해야.

### Hyrum's Law

다른 엔지니어들에게 사용되는 프로젝트를 맡고 있다면, Hyrum's Law가 "it works"와 "it is maintainable"의 차이에 대한 중요한 교훈이 됨.

> With a sufficient number of users of an API, it does not matter what you promise in the contract: all observable behaviors of your system will be depended on by somebody.

### Why Not Just Aim for "Nothing Changes"?

- 새로운 기능을 지속적으로 제공해야 하고
- 보안 취약점이 새로 발견되고
- 버그도 계속 발견됨
- CPU 등의 변경에 따라 최적화도 계속 달라짐
- 수명이 긴 프로젝트라면 변경을 피하기 어려움

## Scale and Efficiency

- 조직과 개발/운영 프로세스 역시 유지 가능해야 한다는 이야기.
- 조직이 커질 때, 그 조직의 반복 작업을 돕는 컴퓨팅 리소스도 함께 스케일링 되어야 함.
- 그렇지 않으면 작업 시간은 점점 늘어나고, 이는 작업을 미루게 되는 배경이 되기도.
- 지속 가능성을 위한 노력의 예시로는 아래와 같은 것들이 있음.
    - 조직 규모에 맞게 테스트 클러스터도 함께 확장 되어야 함.
    - 전체 빌드에 걸리는 시간, 리포지토리를 pull 받는 데 걸리는 시간도 커지지 않도록.
    - 새로운 버전의 랭귀지로 업그레이드 하는 데 걸리는 시간들도 마찬가지.
- 이런 문제들은 서서히 자라나며 잘 인식하지 못할 수 있음.
- [bolied frog](https://en.wikipedia.org/wiki/Boiling_frog#As_metaphor)를) 언급하며 이런 특징을 가진 문제들의 위험성을 강조.

### Policies That Don't Scale

- 조직이 커지거나 코드 베이스가 커질 때 일의 양도 같이 늘어난다면 not scale.
- 그 일의 자동화나 최적화를 하는 메커니즘이 적절한 곳에 있어야 함.
- 일반적인 deprecation 접근법을 스케일 문제의 예로 들고 있음.
- 새로운 위젯을 만들었다고 가정.
- 그리고 기존 것의 사용을 중단하고 새로운 것의 사용을 강제.
- 작은 소프트웨어에서는 이것이 가능할 수도.
- 그러나 의존성 그래프가 깊고 넓은 경우엔 실패하기 쉬움.
- 회사의 성장 속도를 저해하는 요인이 되기도.
- 대신, 하위 호환성을 유지하는 방식을 권장.
- 의존 프로젝트들은 더 이상 따라잡기 위한 급진적 노력을 기울이지 않아도 됨.

### Policies That Scale Well

- 한 가지 사례는 인프라스트럭처 팀의 안전한 변경을 보호하는 정책.

> If a product experiences outages or other problems as a result of infrastructure changes, but the issue wasn't surfaced by tests in out CI system, it is not the fault of the infrastructure change.

- 공통 CI 시스템에서 실행되지 않는 맞춤형의 복잡한 테스트는 신경쓰지 않는다는 것.
- 그렇지 않으면 인프라 팀은 영향 받는 모든 팀의 코드를 추적하고 테스트는 어떻게 했는지 일일이 물어봐야 함.
- 100명의 엔지니어가 있을 때는 이것이 가능했으나 규모가 커진 지금은 불가능.
- 대신, 공유된 커뮤니케이션 포럼과 전문 지식이 조직의 규모 확장에 도움.
- 엔지니어들이 공유 포럼에서 토론하고 질문에 응답하면서 지식이 전파되고 전문가들이 생겨남.

### Shifting Left

- 개발 단계의 앞 쪽에서 버그나 보안 이슈를 발견하고 대응할 수록,
- 더 적은 비용을 감수한다는 일반적인 이야기가 갑자기 나옴.
- 일반적으로 보던 개발 단계가 뒤로 갈수록 비용이 지수적으로 늘어나는 그래프도 소개.

## Trade-offs and Costs

- 프로그램을 작성, 소프트웨어의 생명주기, 엔지니어 규모 확장 시에도 소프트웨어를 유지하는 것을 이해했다면, 남은 것은 올바른 결정 내리기.
- 구글 내에서는 "내가 그렇게 말했기 때문"에 대한 강한 혐오감이 있음.
- 모든 것에는 이유가 있어야.
- 그리고 어느 주제든 결정자가 있어야 함.
- 잘못된 것 같아 보이는 결정에 대해서는 이의 제기.
- 다만 목표는 만장일치가 아니라 합의.
- 이런 의사 결정시에는 여러 비용을 고려해야 하는데,
- 재정적, 리소스 측면 등과 같은 것 뿐만 아니라 사회적 비용이나 구성원들의 만족감 같은 비용도 포함.

### Example: Markers

- 구글을 데이터 중심 문화라고 불러주지만 너무 단순화 된 얘기.
- 데이터가 없는 경우에는 증거, 선례, 논쟁으로 결정.
- 모든 가능한 선택지를 두고 트레이드 오프를 고려하며 현명한 결정을 내리려 노력.
- 때때로 직감이나 베스트 프랙틱스에 기반한 결정이 이뤄지기도 하지만, 근본적이고 실제적인 비용을 측정하거나 추정하는 모든 방식을 다 사용한 이후에나 가능.

### Inputs to Decision Making

- CPU와 네트워크 간 트레이드 오프 측정과 같이,
- 결정을 내리기 위한 데이터가 측정할 수 있거나 적어도 추정이 가능한 것들이 있음.
- 한편, 측정하기 어렵거나 측정 방법조차 모를 때도.
- 잘 설계 되지 못한 API가 가져오는 비용 측정이 그 예.
- 후자의 것도 측정하기 위한 노력을 하긴 하지만, 측정이나 예측하기 어렵다는 것도 인정하면서, 우선순위를 낮추지 않고 계속 다루려 노력해야 함.

### Example: Distributed Builds

- 로컬 빌드가 오래 걸려서 점점 문제가 됐음.
- 빌드를 최대한 빠르게 하는 방법을 고민하기 시작.
- 고성능 개발 장비는 대부분 유휴 상태이기 때문에 좋은 선택은 아니라고 판단.
- 구글은 자신들만의 분산 빌드 시스템을 만들었음.
- 물론, 이를 만드는 비용도 발생했고, 개발자들의 습관/워크플로우을 바꾸는 데에도 많은 시간이 걸림. 컴퓨팅 리소스는 당연.
- 하지만 전체적으로 아낄 수 있는 시간이 컸음.
- 그래서 헤피 엔딩이냐. 꼭 그런 것만은 아님.
- 로컬에서는 커지지 않게 신경 쓰던 의존성이 마구 늘어남.
- 실행 환경이 빠르기 때문에 신경 쓰지 않아도 문제가 되지 않았던 것.
- Jevons 역설.

### Example: Deciding Between Time and Scale

- 문제 해결을 위해 라이브러리 등의 의존성을 추가할 수도 있음.
- 또는 좀 더 요구에 들어맞도록 이를 포크/재개발을 할 수도 있음.
- 맞춤형은 새로운 기능을 추가하기도 쉽고, 최적화에도 유리. 의존성의 변경으로부터 자유롭기도.
- 하지만 모든 것을 직접하게 되면, 확장성과 더불어 지속가능성이 떨어짐.
- 보안 이슈를 단지 의존성 업데이트 만으로 해결할 수 없는 것이 그 예.

# 2. How to Work Well on Teams

- 구글 소프트웨어 엔지니어링의 문화적, 사회적 측면을 다루는 부분.
- 통제 가능한 변수인 우리 자신에 초점을 맞추는 것으로 시작.
- 소프트웨어 개발은 팀의 노력.
- 엔지니어링 팀의 성공을 위해 겸손, 존중, 신뢰 기반의 행동이 필요.

## Help Me Hide My Code

- 사람들은 자신이 작업 중인 것을, 다른 사람이 보고 판단하는 것을 두려워 하는 경향이 있다는 이야기.
- 이런 불안함은 더 큰 문제의 징후라는 얘기도 함.

## The Genius Myth

- 사람들은 우상을 찾고 숭배하려는 성향이 있음.
- 리누스 토발즈의 리눅스도 분명 그의 초기 작업이 훌륭하긴 했지만,
- 그 이후의 수 많은 똑똑한 사람들의 노력 없이는 불가능한 결과물.
- 그리고 많은 엔지니어들이 천재처럼 보이길 원한다고 함(하지만 대부분 천재는 아님).
- 이런 천재 신화는 위에서 말한 불안함의 또 다른 징후.
- 그래서 작업 중인 것을 공유하길 꺼려함.
- 천재 신화를 떠나, 단지 좋은 모습만을 보여주고자 하는 마음에, 이런 경향은 더 만연하다고 생각 됨.

## Hiding Considered Harmful

- 만약 모든 시간을 혼자 일하는 데 쓰고 있다면,
- 불필요한 실패의 위험을 키우고 성장의 기회를 날리는 것.
- 물론, 소프트웨어 개발이 깊은 집중력과 개인 시간을 어느 정도 필요로 하는 지적 작업이긴 하지만,
- 협업과 리뷰 역시 매우 중요한 요소.
- 무엇보다도 당신이 올바른 길을 가고 있는지를 어떻게 알 수 있겠는가?

### Early Detection

- 뭔가 완성되기 전까지 공개하는 것을 꺼리는 건 도박.
- 초반일수록 실수하기 쉬움.
- 제대로 하고 있는지를 다른 사람에게 피드백 받으며 반복 확인하고 수정해야 함.
- 처음이 갖는 리스크를 줄이는 일.
- "Fail early, fail fast, fail often"

### The Bus Factor

> the number of people that need to get hit by a bus before your project is completely doomed.

- 프로젝트의 지식과 노하우가 프로젝트에 얼마나 잘 분산되어 있는가?
- 만약, 당신이 프로토타입 코드가 동작하는 원리를 이해하는 유일한 사람이라면,
- 당신이 버스에 치이게 되었을 때 프로젝트는 위험.
- 두 명이서 같이 만들고 있다면 버스 팩터는 2배가 됨.
- 여러 명으로 된 팀으로 일한다면 더 나아짐.
- 영역 별로 2명 이상의 소유자를 갖는 것 외에도 좋은 문서를 두는 것이 프로젝트의 성공을 도움.

### Pace of Progress

- 컴파일하고 일할 때를 생각해보자.
- 한 번에 10,000 라인의 코드를 작성하고 컴파일 버튼을 누르는가?
- 결과는 재앙일 것.
- 프로그래머의 작업은 빽빽한 피드백 루프가 함께 할 때 제일 좋음.
- get feedback as early as possible, test as early as possible, and think about security and production environments as early as possible.
- 모두 "shifting left" 아이디어.
- 이는 코드 레벨 뿐만아니라 전체 프로젝트 레벨에서 필요한 이야기.
- 잘 되는 프로젝트는 빠르게 진화하며 시간이 지남에 따라 바뀌는 환경에 적응해야 함.
- 예상치 못한 설계 장애물이나 정치적 위험을 마주치거나, 단지 계획한 것이 제대로 되지 않기도.
- 요구사항은 계속 변경.
- 이렇게 계획이나 설계가 바로 바로 바뀌어야 한다는 피드백 루프를 어떻게 구성할 수 있을까?
- 답은 팀으로 일하는 것.
- "Many eyes make sure your project stays relevant and on track"

## It's All About the Team

> software engineering is a team endeavor

- 숨어서 비밀 발명품을 준비하는 것으로 세상을 바꾸는 것이 아님.
- 다른 사람들과 함께 일해야 함.
- 비전을 공유하고, 일을 나누고, 서로를 배우며, 훌륭한 팀을 만들어야 함.
- 혼자 만든 소프트웨어 중에 널리 사용되며 성공한 것은 없음.

# 16. Version Control and Branch Management

- VCS는 필수라고 생각.
- 하지만 VCS 전략은 각 상황을 고려하여 선택해야.
- 여러가지 전략과 각각의 장단점을 소개할 예정.
- 그 중에서도 "trunk-based development"가 경험적으로 확장 가능했다고 언급.
- one repository, no dev branches의 의미.

## What is Version Control?

- 시간의 흐름에 따른 파일의 변경(버전)을 추적.
- 이런 파일들의 집합과 메타데이터를 리포지토리라고 부르며 VCS의 관리 대상.
- 여러 개발자가 동시에 작업할 수 있게 해줌.
- 파일을 한 번에 한 사람만 수정할 수 있게 하는 방식으로 이를 지원.
- 이전의 변경이 의도치 않게 덮어 쓰여지는 것을 방지하는 것.

### Why Is Version Control Important?

- 버저닝과 이를 활용한 취소.
- 여러 개발자들 간 또는 여러 시점 간 협업이 가능.
- 커밋은 부수적으로 행위의 변화를 가져오기도 함.
- 커밋 로그를 남기며 변경에 설명을 더하고, 커밋에 앞서 정적 분석이나 체크리스트를 확인하는 등의 행위를 유발시킴.
- VCS를 설치하고 설정하는 등의 단점도 있지만 상대적으로 매우 값싼 비용.

### Centralized VCS Versus Distributed VCS

생략

## Branch Management

- 대비되는 단어는 단일 "trunk"

### Work in Progress Is Akin to a Branch

- 진행 중인 작업은 모두 브랜치에 대응.
- 중앙집중형 VCS에서도 마찬가지.
- 커밋되지 않은 로컬 변경과 브랜치에 커밋된 것은 개념적으로 크게 다르지 않음.

### Dev Branches

- 지속적 단위 테스트가 없던 시절, 변경은 시스템에 대한 regression 위험을 가졌음.
- 이 때는 trunk를 특별한 것으로 간주하는 것이 이치에 맞았음.
- "우리 팀은 피처 개발 브랜치를 사용하고, 트렁크에 커밋하지 않는다"
- "새로운 변경이 모든 검증을 끝내고 난 뒤에야 트렁크로"
- 이것이 제품의 불안정성을 해결하기 위한 적절한 방법이기도 하지만,
- CI나 철저한 코드 리뷰 등의 품질 관리 노력이 더 나은 해결책이라고 주장.
- (이 품질 관리 노력이 어느 정도 수준인지가 중요할 듯. 좋은 해결책이 되기 어려운 수준일 수도)
- 광범위한 개발 브랜치의 사용이 제품 안정성을 위한 수단이 되는 것은 본질적으로 잘못된 것.
- 동일한 커밋들이 결국 트렁크에 병합됨.
- 작은 병합이 더 쉬움.
- 엔지니어는 자신이 작성한 변경을 병합하는 것이 쉬움.
- 관련 없는 변경들의 병합, 그리고 나중에 병합하는 것은 어려움.
- 병합에 대한 회귀 테스트의 실패 책임자가 누구인지 찾는 것도 쉬움.
- 대규모 병합은 문제의 격리를 더 어렵게 함.
- 수정은 더더욱 어려움.
- 규모 확장에도 심각한 위험.
- 병합 자체도 더욱 어려워지고 오래 걸리기 때문.

#### HOW DID WE BECOME ADDICTED TO DEV BRANCHES?

- 오래된 개발 브랜치를 병합하는 것은 안정성을 낮춘다고 판단.
- 그래서 브랜치 병합은 위험하다고 결론.
- 브랜치 기반 개발 전략을 버리고 테스팅으로 문제를 해결하지는 않음.
- 대신, 속도를 낮추고 증상을 조율하는 데 시간을 보냄.
- 조직이 커지면서 브랜치는 늘어나고, 브랜치 병합 전략을 조율하는 데 더 많은 노력이 들어감.
- 일부 개발자는 빌드 마스터/머지 코디네이터/컨텐츠 관리 엔지니어가 됨.
- 대규모 병합이 되면 다른 개발 중인 브랜치들은 이를 또한 반영해야 하며 다시 테스트 해야 함.
- 이런 병합과 반복 테스트는 pure overhead.
- 패러다임의 전환이 필요.
- CI와 테스팅에 크게 의존하며, 빌드를 항상 그린으로 유지하고, 런타임에는 불완전하고/테스트되지 않은 피처는 비활성화 하는, 트렁크 기반의 개발을 권장.
- 하나의 Source of Truth만 있어야 함.
- 릴리즈를 위한 하나의 리비전만 있게 됨.
- 이는 1장에서 소개했던 "shift left"(이제서야 나오는 구나) 접근법.

### Release Branches

- 릴리즈 간격이 몇 시간 보다 길다면 릴리즈 브랜치를 만드는 게 합리적일 수도.
- 그리고 만약 릴리즈 사이에 큰 결함이 발견되면 트렁크에서 릴리즈 브랜치로 수정 사항을 cherry-pick.
- 개발 브랜치와 비교하면 릴리즈 브랜치는 일반적으로 무해함.
- 개발 브랜치와 릴리즈 브랜치의 주요 차이는 종료 상태.
- 릴리즈 브랜치는 결국엔 제거됨(abandoned).
- 하지만 개발 브랜치는 계속 트렁크로 병합되고, 다른 팀에 의해 추가적으로 분기되기도.
- 높은 수준의 조직에서는 릴리즈 브랜치가 거의 없다고 함.
- 지속적 배포(하루에도 여러 번 릴리즈)를 달성하는 곳은 릴리즈 브랜치를 생략하는 경향.
- 단순하게 수정을 반영하고 재배포 하는 것이 더 쉬움.
- cherry-pick과 브랜치는 불필요한 오버헤드.
- 물론, 고객에게 명시적인 릴리즈 결과물을 제공하는 곳에서는, 고객에게 정확히 무엇이 전달되었는지가 중요하기에, 이 방식의 적용은 어려울 수도.
- 복잡한 브랜치와 머지 전략은 생산성의 장애물.
- 트렁크를 안정된 상태로 유지하는 다른 방법들이 있음.

## Version Control at Google

- 구글에선 50,000명의 엔지니어가 공유하는 하나의 리포지토리를 사용(monorepo).
- 구글에서 진행하는 대부분의 프로젝트가 여기에 모여 있음. 오픈소스만 제외.
- Gmail 등의 공개 제품 외에 제품 개발을 지원하는 데 필요한 내부 인프라까지도 포함.
- Piper라고 불리는 중앙화된 인하우스 VCS를 사용.
- 하루에 보통 60,000 ~ 70,000개의 커밋이 일어남.
- 트렁크에 새로운 클라이언트를 생성하고, 파일을 추가하고, 리뷰되지 않은 변경을 커밋하는 것은 15초 정도 소요.
- 참고로, Piper는 사내에서 만들어 졌기에 커스터마이징도 쉬움.
- 리포지토리 하위 트리의 커밋들을 승인할 수 있는 엔지니어 이름이 적힌 OWNERS라는 파일들이 있음.
- 이를 활용해서 Piper가 소유/승인이 좀 더 잘 이뤄질 수 있게 하고 있음.

### One Version

- Piper 도구가 강력하긴 하지만, 그것만으로는 지금과 같은 협업은 어려움.
- "One Version"이라고 불리는 버전 컨트롤 '정책'이 필요.
- 이 정책은 "Single Source of Truth" 개념의 확장이며 아래와 같음.

> Developers must never have a choice of "What version of this component should I depend upon?

- 개인에겐 이런 선택의 제한이 장애물로 보일 수도.
- 그러나 조직 차원에서 이는 효율적인 스케일링의 매우 중요한 요소.

### (Nearly) No Long-Lived Branches

- One Version Rule에는 좀 더 깊은 생각과 정책들이 내포되어 있음.
- 그 중 가장 중요한 것은 아래와 같음.

> development branches should be minimal, or at best be very short lived

- Phoenix Project의 "reducing work-in-progress" 교훈은 개발 브랜치에 적용한 것.
- 트렁크에 작은 증분만이 이뤄져야 하고, 정기적으로 커밋 되어야 함.
- 그리고 준비 되기 전까지는 런타임에 비활성화 되어야 함.
- 더불어, 가능하다면 가시성을 통해 다른 개발자에게 숨겨져야.
- 혹은 두 의존성이 하나의 프로그램 내에서 공존할 수 있도록 설계되어야(패키지/클래스 명 등의 충돌이 없어야 한다는 의미로 들림).
- 구글에서는 1,000개 팀에서 이런 개발 브랜치를 가진 곳은 2군데.
- 흔한 일이 아니며 매우 특수한 이유를 가짐.

### What About Release Branches?

- 많은 구글팀에서 릴리즈 브랜치를 사용(제한된 체리 픽과 함께).
- 월간 릴리즈를 준비를 하면서 다음 릴리즈를 작업하는 경우에 이상적.
- 체리 픽을 최소화하고, 트렁크와의 재병합 계획은 금지.
- 아마도 여기서의 릴리즈 브랜치는, 트렁크에서 릴리즈 브랜치를 따고 그 릴리즈 브랜치로 배포가 나가는 형태인 것으로 보임.

## Monorepos

- One Version 유지를 쉽게 만들어 줌.
- 어떤 버전이 오피셜인지 결정하는 프로세스도 없고,
- 어떤 리포지토리를 봐야 하는지 고민할 필요도 없음.
- 빌드 도구 입장에서도 리포지토리를 고르는 절차 없음.
- 이런 일관성은 새로운 도구나 최적화 도입 등의 스케일링을 쉽게 도와줌.
- 엔지니어들의 코드나 시스템 디자인 결정을 공유하기도 쉬움.
- 다만, monorepo 방식이 결국엔 One Version을 위한 수단.
- 이 목적을 달성하기 쉽다면 다른 수단들도 충분한 대안이 될 수 있음.
