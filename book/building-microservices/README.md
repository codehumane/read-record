
# 마이크로서비스 아키텍처 구축

> 몇 년 만에 다시 읽는 책. 빠르게 다시 읽어 보는 중인데 여전히 재밌음. 그래서 간단히 기록까지 진행.

## 통합

### 비동기 아키텍처의 복잡성

- 어느날 작업자 서버들이 줄줄이 죽어 나감.
- 특정 가격 책정 요청이 작업자를 망가뜨렸고,
- 요청은 타임 아웃되어 큐의 뒤로 밀려남.
- 다른 작업자들이 이 요청을 꺼낼 때마다 같은 일이 반복.
- 마틴 파울러가 말한 [catastrophic failover](https://www.martinfowler.com/bliki/CatastrophicFailover.html).
- 버그도 잘못이지만 재시도 최댓값도 설정하지 않았던 것.
- 필요하면 잘못된 메시지도 확인할 수 있어야 하고 재현도 가능해야 했음. (결국 UI로 만들었다고)
- 실패한 메시지가 이송되는 message hospital 또는 DLQ를 구현해야 했다고 함.
- 요청을 추적할 수 있도록 correlation ID의 사용도 적극 검토할 것.

### 버전 관리

- XPath를 이용한 Tolerant Reader 패턴 사용 등 가능한 버전 분기를 지연.
- CDC를 통해 호환성을 깨뜨리는 변경 일찍 찾아내기.
- 클라이언트가 서비스 버전 번호만 보고도 통합을 판단할 수 있도록 semantic versioning 사용.
- 다른 버전의 엔드포인트와 공존. 다만, 확장-수축 패턴을 통해 모든 코드를 관리하고 테스트하는 부담을 줄여라.
- 드물지만, 버전이 다른 독립된 서비스를 동시에 운영하기도. 추천 X. 버그 발견 시 두 벌을 수정해야 하고, 라우팅에 부가적 로직이 필요하며, 저장된 데이터가 모든 버전에 호환되어야 하는 노력이 수반됨.

### API 구성

- 여러 컴포넌트로 구성된 화면이 있음.
- UI 측에서 컴포넌트 별로 다른 서비스를 호출할 수도 있으나 호출 수와 데이터 양 등에서 문제가 됨.
- 한편, 화면에 필요한 UI를 API로부터 제공 받을 수도. 하지만 다양한 종류(HTML, 네이티브, ...)의 지원은 쉽지 않음.
- API 게이트웨이를 둘 수도 있음. 하지만, 동작이 많아지면 이 계층이 두터워지고 재앙(독립적 릴리즈가 어려워지는 등)이 되기도 함.
- 대안으로 BFF 제시. 특정 UI에 집중하는 팀마다 전용 서버 측 컴포넌트도 담당.
