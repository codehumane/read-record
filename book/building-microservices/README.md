# 마이크로서비스 아키텍처 구축

> 몇 년 만에 다시 읽는 책. 빠르게 다시 읽어 보는 중인데 여전히 재밌음. 그래서 간단히 기록까지 진행.

## 서비스 모델링하기

### 무엇이 좋은 서비스를 만드는가

- 느슨한 결합. 특정 서비스만 변경하고 배포하기.
- 강한 결합을 일으키는 전형적 실수는 서로 강하게 엮이는 통합 방식의 적용.
- 예컨대 DB를 통한 통합이나 지나친 오케스트레이션.
- 책에서는 오케이스트레이션의 문제를 아래의 문장으로 설명하기도 함.
- 한편, 강한 응집력도 언급. 책의 설명은 부족. 이는 의존성을 줄이기도 하지만, 빠르고 가볍고 이해하기 쉬운 서비스 도출에 도움 될 것.

> 빈약한 CRUD 기반의 서비스에 할 일을 지시하는 소수의 똑똑한 '신'과 같은 서비스

### 경계가 있는 컨텍스트

- bounded context 이야기.
- 각자만의 문맥이 존재하고, 공유될 부분은 인터페이스(번역) 제공.
- 뮤직코퍼레이션 예시.
    - 창고 문맥 내부에는 주문 수집자(주문 내역을 집어다는), 선반(재고 품목의 위치를 보여주는) 등의 개념이 존재.
    - 여기서 외부로 공유되는 것은 재고 품목.
    - 이를 공유 받는 재무 문맥은 계정원장 등의 내부적인 개념을 관리.
- 같은 용어가 서로 다른 문맥에서 조금씩 다른 의미로 사용되는 번역 사례도 소개. (문맥을 구분 짓는 중요한 요소)
- 이런 경계는 모듈이나 서비스의 형태로 구분.
- 성급한 분해도 경계. 기존 코드베이스를 분해 > 처음부터 마이크로서비스.

### 비즈니스 능력

- 빈약한 CRUD 기반의 서비스에 대한 경계. (자율성 부족, 결합도 상승)
- 서비스를 모델링할 때 주요 행위가 무엇인지를 생각할 것.

### 기술적 경계

- 기술에 따라 경계를 나누는 것.
- 프론트엔드, DB 접근 서비스, DB.
- 일종의 수평적 확장.
- 항상 나쁜 것은 아님.
- 하지만 첫 번째가 아닌 두 번째 목표가 되어야 함.

## 통합

### 비동기 아키텍처의 복잡성

- 어느날 작업자 서버들이 줄줄이 죽어 나감.
- 특정 가격 책정 요청이 작업자를 망가뜨렸고,
- 요청은 타임 아웃되어 큐의 뒤로 밀려남.
- 다른 작업자들이 이 요청을 꺼낼 때마다 같은 일이 반복.
- 마틴 파울러가 말한 [catastrophic failover](https://www.martinfowler.com/bliki/CatastrophicFailover.html).
- 버그도 잘못이지만 재시도 최댓값도 설정하지 않았던 것.
- 필요하면 잘못된 메시지도 확인할 수 있어야 하고 재현도 가능해야 했음. (결국 UI로 만들었다고)
- 실패한 메시지가 이송되는 message hospital 또는 DLQ를 구현해야 했다고 함.
- 요청을 추적할 수 있도록 correlation ID의 사용도 적극 검토할 것.

### 버전 관리

- XPath를 이용한 Tolerant Reader 패턴 사용 등 가능한 버전 분기를 지연.
- CDC를 통해 호환성을 깨뜨리는 변경 일찍 찾아내기.
- 클라이언트가 서비스 버전 번호만 보고도 통합을 판단할 수 있도록 semantic versioning 사용.
- 다른 버전의 엔드포인트와 공존. 다만, 확장-수축 패턴을 통해 모든 코드를 관리하고 테스트하는 부담을 줄여라.
- 드물지만, 버전이 다른 독립된 서비스를 동시에 운영하기도. 추천 X. 버그 발견 시 두 벌을 수정해야 하고, 라우팅에 부가적 로직이 필요하며, 저장된 데이터가 모든 버전에 호환되어야 하는 노력이 수반됨.

### API 구성

- 여러 컴포넌트로 구성된 화면이 있음.
- UI 측에서 컴포넌트 별로 다른 서비스를 호출할 수도 있으나 호출 수와 데이터 양 등에서 문제가 됨.
- 한편, 화면에 필요한 UI를 API로부터 제공 받을 수도. 하지만 다양한 종류(HTML, 네이티브, ...)의 지원은 쉽지 않음.
- API 게이트웨이를 둘 수도 있음. 하지만, 동작이 많아지면 이 계층이 두터워지고 재앙(독립적 릴리즈가 어려워지는 등)이 되기도 함.
- 대안으로 BFF 제시. 특정 UI에 집중하는 팀마다 전용 서버 측 컴포넌트도 담당.
