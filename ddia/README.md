# Designing Data-Intensive Application

## Storage and Retrieval

### Data Structures That Power Your Database

```bash
#!/bin/bash

db_set () {
    echo "$1,$2" >> database
}

db_get () {
    grep "^$1," database | sed -e "s/^$1,//" | tail -n 1
}
```

- 아주 간단한 데이터베이스.
- 매 라인마다 쉼표로 구성된 키-값 쌍의 텍스트 파일을 활용.
- 기존 값을 갱신하지 않고 계속 쌓기만 하는 append-only.
- 데이터 베이스의 로그가 바로 이런 형태.
- 로그가 너무 커지지 않게 디스크 공간 회수나 오류 처리, 동시성 제어 등의 문제 해결이 필요하긴 하지만, 기본적으로는 같은 원리.
- 하지만, 레코드가 많아지면 검색 성능이 나빠짐. 특정 키를 찾기 위해, 처음부터 끝까지 스캔해야 하기 때문. O(n).
- 키 찾기의 효율성을 위해 활용되는 것이 바로 색인.
- 하지만 쓰기 속도는 느려짐.
- 이런 트레이드 오프로 인해 데이터베이스는 모든 것을 색인하지 않음. 사용자의 선택.

#### Hash Indexes

키-값 저장소를 해시 맵으로 색인하기.

- [해시 맵 인덱스 그림](https://www.safaribooksonline.com/library/view/designing-data-intensive-applications/9781491903063/assets/ddia_0301.png) 참고.
- 키를 데이터 파일의 바이트 오프셋에 매핑해 인메모리 해시 맵을 유지.
- 단순하지만 Bitcask 등 실제로 많이 사용됨.
- 고유키가 많지 않으면서도(메모리에 적재해야 하므로) 값의 갱신이 빈번한 경우에 유리.

만약, 디스크 상의 로그 구조화 파일에 계속 append만 되서 공간이 부족해 진다면?

- 로그를 특정 크기의 세그먼트<sup>segment</sup>로 나누기.
- 세그먼트가 특정 크기에 도달하면, 세그먼트를 닫고 이후의 쓰기는 새로운 세그먼트에 수행.
- 닫힌 세그먼트에 대해서는 일반적인 컴팩션<sup>compaction</sup> 수행.
- 당연히, 여러 개의 세그먼트에 대해서도 컴팩션 가능.

구현 시 주의 사항들

- CSV 형식은 로그에 부적합. 문자열 길이를 바이트 단위로 인코딩 후, 원시 문자열을 인코딩 하는 것이 빠르고 간편함. 이스케이핑도 필요 없어짐.
- 키 관련 값을 삭제하려면 특수한 삭제 레코드(tombstone이라고도 불림)을 추가. 세그먼트 병합 시 이 키의 이전 값들은 무시됨.

추가 전용 로그의 장단점

- 순차적 쓰기 작업으로, 무작위 쓰기에 비해 훨씬 빠름.
- 동시성과 고장 복구에 유리. 고장의 경우 별도의 파일에 추가한 뒤 병합하면 됨.
- 반면, 해시맵은 메모리에 저장해야 빠르므로, 너무 큰 색인은 불가.
- 범위 질의가 비효율적. 해시 맵에서 일일이 모든 개별 키를 조회해야 함.

#### SSTables and LSM-Trees

먼저, 로그 구조화 저장소에 대한 간단한 요약.

- 로그 구조화 저장소 세그먼트는 [이 그림](https://www.safaribooksonline.com/library/view/designing-data-intensive-applications/9781491903063/assets/ddia_0303.png)에서 보듯이 키-값 쌍의 연속.
- 이 쌍은 쓰여진 순서대로 나타남. 또한, 키 값이 같으면 나중의 값이 이전 값에 우선함.

SS 테이블의 등장.

- 만약, 세그먼트에서 일련의 키-값 쌍을 키로 정렬해야 한다면?
- [이 그림](https://www.safaribooksonline.com/library/view/designing-data-intensive-applications/9781491903063/assets/ddia_0304.png)에서 보는 것 처럼 세그먼트 병합시 정렬 상태를 만들 수 있다.
- 이렇게 키로 정렬된 형식을 가리켜 정렬된 문자열 테이블<sup>Sorted String Table</sup>이라고 함. 또는 SS 테이블.

SS 테이블은 해시 색인을 가진 로그 세그먼트에 비해 몇 가지 장점을 가짐.

- 세그먼트 병합은 파일이 사용 가능한 메모리보다 크더라도 간단하고 효율적. 병합정렬 알고리즘과 유사하기 때문. (다만, 이게 왜 해시 색인을 가진 세그먼트의 병합 과정에 비해 장점인지는 잘 모르겠음)
- 더 이상 파일에서 특정 키를 찾기 위해 메모리에 모든 키의 색인을 유지할 필요가 없음. (DB 인덱스를 생각하면 금방 이해 됨)
- 레코드들을 블록으로 그룹화하고, 디스크에 쓰기 전에 압축할 수 있음. 인메모리 색인은 압축된 블록의 시작을 가리키면 됨. 이렇게 하면, 디스크 공간 절약과 I/O 대역폭 사용도 줄임.

##### Constructing and Maintaining SSTables

SSTables를 어떻게 유지할 수 있을까?

- 쓰기가 유입되면, in-memory balanced tree 데이터 구조(red-black tree와 같은)에 추가. 이런 인메모리 트리를 가리켜 종종 `memtable`이라고도 부름.
- memtable의 크기가 임계치를 넘어가면, SSTable 파일로 옮긴다. 트리가 이미 키로 정렬된 키-밸류 쌍이므로 효율적으로 수행 가능. 새로운 SSTable이 디스크에 작성되는 동안, 쓰기는 새로운 memtable 인스턴스에서 계속 됨.
- 읽기 요청을 처리하기 위해, 우선 memtable에서 키를 찾고, 다음으로 가장 최신의 디스크 세그먼트, 그리고 그 다음 세그먼트, ...를 찾는다.
- 종종 백그라운드에서 병합과 압축 과정을 수행. 세그먼트 파일을 합치면서 덮어씌워졌거나 삭제된 값을 버림.

하지만, 만약 데이터베이스가 고장나면?

- 최근의 쓰기들은 유실될 수 있음.
- 이를 피하기 위해 별도의 분리된 로그를 유지.
- 이 로그에는 쓰기가 발생하는 순서 그대로 즉각 기록.
- 고장시 복구를 위한 목적이므로 순서는 상관 없음.
- memtable이 SSTable로 옮겨질 때 마다, 대응되는 로그들은 버려짐.

##### Making an LSM-Tree Out Of SSTables

- 여기서 소개된 알고리즘은 LevelDB와 RocksDB 등에서 사용됨.
- Cassandra와 HBase에는 이와 유사한 저장소 엔진이 사용됨.
- 이런 인덱싱 구조는 원래 *Log-Structured Merge-Tree (LSM-Tree)*라는 이름으로 소개되었음.
- 정렬된 파일을 병합하고 압축하는 원칙에 기반하는 저장소 엔진들은 종종 LSM 저장소 엔진이라 불림.
- 루신(Elasticsearch와 Solr에서 사용되는 인덱싱 엔진)은 *term dictionary*를 저장하기 위해 비슷한 방식을 사용. 키는 단어(*a term*), 값은 이 단어가 포함된 모든 문서의 ID 목록(*the postings list*). 이 매핑이 SSTable 같은 정렬된 파일에 유지됨. 그리고 필요에 따라 백그라운드에서 병합됨.

#### B-Trees

- SS(Sorted String)테이블과 같이 정렬된 키-값 쌍을 유지.
- 따라서, 키-값 검색과 범위 질의에 효율적.
- 가변적 단위인 세그먼트 아니라, (일반적으로) 4KB라는 고정 크기의 블록이나 페이지 단위로 나눔.
- 한 페이지에서 참조하는 하위 페이지의 수를 가리켜 분기 계수<sup>branching factor</sup>라고 함. 보통 수백 개에 달함.
- 키 값의 갱신은 [여기 그림](https://www.safaribooksonline.com/library/view/designing-data-intensive-applications/9781491903063/assets/ddia_0307.png) 참고.

##### Making B-Trees Reliable

- 로그 구조화 색인과 대조적으로 새로운 데이터를 기존 페이지에 덮어 씀.
- 일부 동작은 여러 다양한 페이지의 덮어쓰기가 수반됨. 고아 페이지에 유의.
- 고장 복구를 위해 디스크 상의 쓰기 전 로그<sup>write-ahead log</sup>를 쌓음. 재실행 로그<sup>redo log</sup>라고도 불림.
- 다중 스레드가 동일한 페이지 갱신에 유의. 보통 레치<sup>latch</sup> 즉, 가벼운 잠금으로 이를 보호함.

##### B-Tree Optimizations

- 페이지를 오버라이트하거나 WAL을 유지하는 대신, 일부 데이터베이스들은 copy-on-write 스키마를 사용. 동시성 제어에 유리. 일종의 READ-COMMITTED.
- 키 전체 대신 축약 버전을 저장. B+ 트리를 일컫는 것.
- 리프 페이지들은 디스크 상에서 연속된 순서로 나타나게끔 배치를 시도.
- 트리에 포인터 추가. 리프 페이지가 양쪽 형제들에 대한 참조를 가지면, 상위 페이지로 가지 않아도 순서대로 키 스캔이 가능.

#### Comparing B-Trees and LSM-Trees

경험적으로 LSM-트리가 쓰기에 빠르고, B-트리가 읽기에 빠름.

##### Advantages of LSM-Trees

- B-트리는 매번 적어도 두 벌의 쓰기를 해야 함. 하나는 write-ahead log, 다른 하나는 트리 페이지 그 자체. 때로는 페이지의 몇 바이트만을 바꾸기 위해 전체 페이지를 한 번에 기록해야 하기도.
- 로그 구조화 인덱스도 SSTable을 병합하고 압축하는 것을 반복하기 때문에 여러 번 데이터를 기록. 한 번의 쓰기가 데이터베이스의 생명주기 동안 여러 번의 쓰기를 야기할 수 있다는 점에서 쓰기 증폭<sup>write amplification</sup>. 
- 쓰기가 많은 애플리케이션에서는 디스크에 기록하는 속도가 성능의 병목이 됨. 따라서, 쓰기 증폭은 성능에 직접적인 비용이 됨. 저장소 엔진이 디스크에 많이 쓸수록, 디스크 대역폭은 줄어들기 때문.
- 제목은 LSM-트리의 장점인데 왜 이런 얘기가 계속 나오는지 의아함.
- 하지만, LSM-트리는 B-트리에 비해 일반적으로 더 좋은 성능을 보임. 종종 낮은 쓰기 증폭을 가지고, 트리에서 처럼 여러 페이지에 대해 덮어쓰기를 하기 보다는 차례대로 SSTable 파일들을 압축하기 때문. 순차적 쓰기가 랜돔 쓰기에 비해 훨씬 더 좋은 성능을 보이는 마그네틱 하드 드라이브에서 특히 중요한 차이.
- LSM-트리가 더 잘 압축되므로 더 작은 디스크 용량을 차지. 반면, B-트리는 파편화로 인해 사용되지 않는 디스크 공간이 남게 됨.

##### Downsides of LSM-Trees

- 압축 과정이 때때로 진행중인 읽기와 쓰기 성능에 간섭을 줄 수 있음.
- 압축 과정은 또한 initial write(memtable → 디스크 로깅과 플러시)가 일어날 때 성능 문제가 될 수 있음.
- 쓰기가 늘어나는 속도를 압축이 따라가지 못하면 디스크 공간이 부족해 질 수 있음.
- 로그 구조화 저장소 엔진은 중복된 키가 여러 세그멘트에 걸쳐 존재할 수 있어 트랜잭션 처리에 불리. 트랜잭션 격리는 키 범위에 대한 잠금을 이용해 구현됨.

#### Other Indexing Structures

TBD