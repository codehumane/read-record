# Redis Cluster Specification

## Main properties and rationales of the design

### Redis Cluster goals

1. 높은 성능과 선형적 확장성(1000 노드까지) 제공.
2. 프록시 없고, 비동기 레플리케이션 사용되며, 값에 대한 병합 연산 없음.
3. 수용 가능한 수준의 쓰기 안전성 (이 문서에 나온 설명보다는 [여기](https://github.com/codehumane/what-i-learned/blob/master/document/redis-cluster-tutorial.md#redis-cluster-consistency-guarantees) 내용이 더 설명적.
4. 가용성
   - 파티션이 발생하더라도, 대다수의 마스터 노드들이 모두 도달 가능하고,
   - 나머지 마스터는 도달 불가하지만 적어도 1개 이상의 도달 가능한 슬레이브가 있으면, RC는 계속 살아 있음.
   - replicas migration을 사용하면, 다른 마스터로부터 가용한 슬레이브를 얻을 수도.

### Implemented subset

1. 모든 싱글 키 커맨드는 비-분산 버전 레디스에서 모두 사용 가능.
2. 같은 노드에 속하는 키라면, 복잡한 멀티-키 연산(Set 타입의 합집합이나 교집합 등) 가능.
3. [hash tags](https://redis.io/topics/cluster-spec#keys-hash-tags) 기능도 제공함. 하지만, 수동으로 리샤딩을 하는 동안에는 멀티-키 연산을 불가할 수 있음.
4. stand alone 모드에서 지원하는 멀티 DB를 RC는 지원하지 않음.

### Clients and Servers roles in the Redis Cluster protocol

1. RC 노드의 역할은 다양함.
   - 데이터 보유.
   - 클러스터 상태 관리.
   - 노드를 찾아가기 위한 키 매핑.
   - 다른 노드에 대한 자동 복구.
   - 동작하지 않는 노드 감지.
   - 슬레이브 노드의 마스터 승격 등.
2. 이런 역할 수행을 위해 Redis Cluster Bus를 구성.
   - TCP 버스와 바이너리 프로토콜로 연결된 것.
   - 가십 프로토콜을 사용해서 새로운 노드를 발견하기 위한 정보를 전달하고,
   - 다른 노드들이 모두 정상적으로 동작하는지 확인하기 위해 핑 패킷을 전송하는 등의 일을 함.
   - 또한, Pub/Sub 메시지를 보내는 데에도 클러스터 버스가 사용되고,
   - 사용자에 의해 요청된 메뉴얼 페일오버 오케스트레이션에도 사용.
3. 프록시 노드가 없고, 리다이렉션 에러(-MOVED와 -ASK)를 사용함.
   - 요청이 리다이렉트 되기 때문에, 이론적으로는 클라이언트가 클러스터의 모든 노드에 요청을 던질 수 있음.
   - 이렇게 되면 클라이언트는 클러스터의 상태를 가지고 있지 않아도 됨.
   - 그러나, 클라이언트는 키와 노드 간의 매핑을 캐싱해서 성능 향상을 꾀할 수 있음.

### Write safety

1. RC는 노드간 비동기 레플리케이션을 사용.
2. 그리고 충돌 해결 전략으로 last failover wins 사용. (책은 implicit merge function이라고 표현)
3. 즉, 마지막으로 선출된 마스터의 데이터셋이 결과적으로 다른 모든 레플리카를 대체.
4. 파티션이 발생하는 동안에는 데이터가 유실될 가능성이 항상 존재.
5. 아래는 다수 파티션으로 요청한 쓰기가 성공했음에도 데이터가 유실될 수 있는 한 사례.

```
- 쓰기가 마스터에 전달됨.
- 클라이언트에게 성공을 응답.
- 동시에 비동기로 슬레이브로 레플리케이션.
- 하지만, 레플리케이션이 끝나기 전에 마스터 노드 죽음.
- 죽어 있는 시간이 임계치를 넘어 임의의 슬레이브가 마스터로 승격.
- 죽은 마스터가 성공적으로 받아들인 쓰기는 유실됨.
```

6. 아래는 다수 파티션에서 발생할 수 있는 또 다른 유실의 사례.

```
- 파티션으로 인해 마스터가 도달 불가.
- 슬레이브에 의해 페일 오버 됨.
- 일정 시간 지난 뒤 원래의 마스터가 다시 도달 가능해짐.
- 라우팅 테이블이 오래된 클라이언트는 원래의 마스터(죽다 살아난)에게 쓰기를 보냄.
- 하지만, 타임아웃 기준과 노드가 실패한 시점 이후로 쓰기를 허용하는 시간이 동일하기 때문에, 실질적 발생 가능성은 매우 낮음.
```

7. 다수가 아닌 소수 측의 파티션에서는 데이터 유실의 가능성이 더 큼.
   - 파티션이 발생했고, 소수 측 파티션에 한 개 이상의 클라이언트가 포함되었다면,
   - 클라이언트는 계속 파티션의 특정 마스터 노드와 연락이 가능하고,
   - 계속 쓰기를 요청하고 성공하지만, 그 대상은 일정 시간 지난 뒤 페일 오버 됨.
8. 다만, 이 유실은 `NODE_TIMEOUT`을 초과한 경우에만, 그리고 `NODE_TIMEOUT` 사이의 쓰기에 대해서만 발생하는 것.

### Availability

1. 소수 측 파티션에서는 RC 이용 불가.
2. 다수 측 파티션에서는 아래와 같음.
   - 대부분의 마스터가 살아 있고,
   - 일부 도달 불가한 마스터에 대해서는 적어도 1개의 슬레이브가 있다면,
   - `NODE_TIMEOUT` + 슬레이브가 마스터로 선출되는 데 걸리는 시간(1~2초)이 지나고 클러스터 이용 가능함.
3. 즉, RC는 일부 노드의 실패에는 살아 남지만, 대규모 네트워크 분할에는 적합치 않은 솔루션.
4. 만약, N개의 마스터 노드가 있고, 각각 1개의 슬레이브를 가졌다면, 1개의 노드가 이용 불가할 때는 살아 남고, 2개의 노드가 문제가 있을 때는 1-(1/(Nx2-1))의 확률로 살아 남을 수 있음. (첫 번째 노드가 실패하면 총 Nx2-1개의 노드가 남고, 이 때 레플리카 없는 마스터가 두 번째로 죽을 확률은 1/(Nx2-1)이 되기 때문)
5. 참고로, replicas migration 피처 덕분에 RC의 가용성이 많이 개선되었다고 함.

### Performance

1. RC는 커맨드를 프록시(주어진 키에 대응되는 노드를 찾아주는) 하지 않음.
2. 대신, 주어진 키 범위를 기반으로 적절한 노드로 요청을 리다이렉트 함.
3. 결국에는 클라이언트가 클러스터의 최신 모습을 알게 되고, 어느 노드들이 키 부분집합을 가지고 있는지도 알게 됨.
4. 따라서, 일반적으로는 클라이언트가 올바른 노드에게 직접 요청을 던지게 됨.
5. WAIT 커맨드를 사용하는 경우를 제외하면, 비동기 레플리리케이션으로 인한 성능상 이점이 있음.
6. 멀티-키 커맨드는 인접<sup>near</sup> 키에 대해서만 허용되므로, 리샤딩을 제외하면 데이터는 절대 노드 간에 이동되지 않음(왜 두 문장이 인과관계인지 잘 이해하지 못하겠음).
7. 일반적인 연산들은 단일 레디스 인스턴스일 때와 동일하게 처리됨. 따라서, 동일한 성능 보장.

### Why merge operations are avoided

1. 레디스에서의 값은 종종 매우 큼. (수백만 엘리먼트가 담긴 list, sorted set)
2. 이런 데이터를 옮기고 병합하는 것은 주요 병목이 될 수 있음.
3. 애플리케이션 측의 추가 로직, 메모리 등이 필요할 수도 있고.
4. 따라서, RC는 다수의 노드에 있는 동일한 키-값 쌍에 대해 버전 충돌을 허용하지 않음.
5. 어떤 기술적 제약이 있는 것이 아님. CRDT나 동기 레플리케이션 상태 머신 등도 레디스와 비슷한 데이터 타입을 가질 수 있음. 그러나 속도는 느려지게 됨.


