# Redis Cluster Specification

## Main properties and rationales of the design

### Redis Cluster goals

1. 높은 성능과 선형적 확장성(1000 노드까지) 제공.
2. 프록시 없고, 비동기 레플리케이션 사용되며, 값에 대한 병합 연산 없음.
3. 수용 가능한 수준의 쓰기 안전성 (이 문서에 나온 설명보다는 [여기](https://github.com/codehumane/what-i-learned/blob/master/document/redis-cluster-tutorial.md#redis-cluster-consistency-guarantees) 내용이 더 설명적.
4. 가용성
   - 파티션이 발생하더라도, 대다수의 마스터 노드들이 모두 도달 가능하고,
   - 나머지 마스터는 도달 불가하지만 적어도 1개 이상의 도달 가능한 슬레이브가 있으면, RC는 계속 살아 있음.
   - replicas migration을 사용하면, 다른 마스터로부터 가용한 슬레이브를 얻을 수도.

### Implemented subset

1. 모든 싱글 키 커맨드는 비-분산 버전 레디스에서 모두 사용 가능.
2. 같은 노드에 속하는 키라면, 복잡한 멀티-키 연산(Set 타입의 합집합이나 교집합 등) 가능.
3. [hash tags](https://redis.io/topics/cluster-spec#keys-hash-tags) 기능도 제공함. 하지만, 수동으로 리샤딩을 하는 동안에는 멀티-키 연산을 불가할 수 있음.
4. stand alone 모드에서 지원하는 멀티 DB를 RC는 지원하지 않음.

### Clients and Servers roles in the Redis Cluster protocol

1. RC 노드의 역할은 다양함.
   - 데이터 보유.
   - 클러스터 상태 관리.
   - 노드를 찾아가기 위한 키 매핑.
   - 다른 노드에 대한 자동 복구.
   - 동작하지 않는 노드 감지.
   - 슬레이브 노드의 마스터 승격 등.
2. 이런 역할 수행을 위해 Redis Cluster Bus를 구성.
   - TCP 버스와 바이너리 프로토콜로 연결된 것.
   - 가십 프로토콜을 사용해서 새로운 노드를 발견하기 위한 정보를 전달하고,
   - 다른 노드들이 모두 정상적으로 동작하는지 확인하기 위해 핑 패킷을 전송하는 등의 일을 함.
   - 또한, Pub/Sub 메시지를 보내는 데에도 클러스터 버스가 사용되고,
   - 사용자에 의해 요청된 메뉴얼 페일오버 오케스트레이션에도 사용.
3. 프록시 노드가 없고, 리다이렉션 에러(-MOVED와 -ASK)를 사용함.
   - 요청이 리다이렉트 되기 때문에, 이론적으로는 클라이언트가 클러스터의 모든 노드에 요청을 던질 수 있음.
   - 이렇게 되면 클라이언트는 클러스터의 상태를 가지고 있지 않아도 됨.
   - 그러나, 클라이언트는 키와 노드 간의 매핑을 캐싱해서 성능 향상을 꾀할 수 있음.

### Write safety

1. RC는 노드간 비동기 레플리케이션을 사용.
2. 그리고 충돌 해결 전략으로 last failover wins 사용. (책은 implicit merge function이라고 표현)
3. 즉, 마지막으로 선출된 마스터의 데이터셋이 결과적으로 다른 모든 레플리카를 대체.
4. 파티션이 발생하는 동안에는 데이터가 유실될 가능성이 항상 존재.
5. 아래는 다수 파티션으로 요청한 쓰기가 성공했음에도 데이터가 유실될 수 있는 한 사례.

```
- 쓰기가 마스터에 전달됨.
- 클라이언트에게 성공을 응답.
- 동시에 비동기로 슬레이브로 레플리케이션.
- 하지만, 레플리케이션이 끝나기 전에 마스터 노드 죽음.
- 죽어 있는 시간이 임계치를 넘어 임의의 슬레이브가 마스터로 승격.
- 죽은 마스터가 성공적으로 받아들인 쓰기는 유실됨.
```

6. 아래는 다수 파티션에서 발생할 수 있는 또 다른 유실의 사례.

```
- 파티션으로 인해 마스터가 도달 불가.
- 슬레이브에 의해 페일 오버 됨.
- 일정 시간 지난 뒤 원래의 마스터가 다시 도달 가능해짐.
- 라우팅 테이블이 오래된 클라이언트는 원래의 마스터(죽다 살아난)에게 쓰기를 보냄.
- 하지만, 타임아웃 기준과 노드가 실패한 시점 이후로 쓰기를 허용하는 시간이 동일하기 때문에, 실질적 발생 가능성은 매우 낮음.
```

7. 다수가 아닌 소수 측의 파티션에서는 데이터 유실의 가능성이 더 큼.
   - 파티션이 발생했고, 소수 측 파티션에 한 개 이상의 클라이언트가 포함되었다면,
   - 클라이언트는 계속 파티션의 특정 마스터 노드와 연락이 가능하고,
   - 계속 쓰기를 요청하고 성공하지만, 그 대상은 일정 시간 지난 뒤 페일 오버 됨.
8. 다만, 이 유실은 `NODE_TIMEOUT`을 초과한 경우에만, 그리고 `NODE_TIMEOUT` 사이의 쓰기에 대해서만 발생하는 것.

### Availability

1. 소수 측 파티션에서는 RC 이용 불가.
2. 다수 측 파티션에서는 아래와 같음.
   - 대부분의 마스터가 살아 있고,
   - 일부 도달 불가한 마스터에 대해서는 적어도 1개의 슬레이브가 있다면,
   - `NODE_TIMEOUT` + 슬레이브가 마스터로 선출되는 데 걸리는 시간(1~2초)이 지나고 클러스터 이용 가능함.
3. 즉, RC는 일부 노드의 실패에는 살아 남지만, 대규모 네트워크 분할에는 적합치 않은 솔루션.
4. 만약, N개의 마스터 노드가 있고, 각각 1개의 슬레이브를 가졌다면, 1개의 노드가 이용 불가할 때는 살아 남고, 2개의 노드가 문제가 있을 때는 1-(1/(Nx2-1))의 확률로 살아 남을 수 있음. (첫 번째 노드가 실패하면 총 Nx2-1개의 노드가 남고, 이 때 레플리카 없는 마스터가 두 번째로 죽을 확률은 1/(Nx2-1)이 되기 때문)
5. 참고로, replicas migration 피처 덕분에 RC의 가용성이 많이 개선되었다고 함.

### Performance

1. RC는 커맨드를 프록시(주어진 키에 대응되는 노드를 찾아주는) 하지 않음.
2. 대신, 주어진 키 범위를 기반으로 적절한 노드로 요청을 리다이렉트 함.
3. 결국에는 클라이언트가 클러스터의 최신 모습을 알게 되고, 어느 노드들이 키 부분집합을 가지고 있는지도 알게 됨.
4. 따라서, 일반적으로는 클라이언트가 올바른 노드에게 직접 요청을 던지게 됨.
5. WAIT 커맨드를 사용하는 경우를 제외하면, 비동기 레플리리케이션으로 인한 성능상 이점이 있음.
6. 멀티-키 커맨드는 인접<sup>near</sup> 키에 대해서만 허용되므로, 리샤딩을 제외하면 데이터는 절대 노드 간에 이동되지 않음(왜 두 문장이 인과관계인지 잘 이해하지 못하겠음).
7. 일반적인 연산들은 단일 레디스 인스턴스일 때와 동일하게 처리됨. 따라서, 동일한 성능 보장.

### Why merge operations are avoided

1. 레디스에서의 값은 종종 매우 큼. (수백만 엘리먼트가 담긴 list, sorted set)
2. 이런 데이터를 옮기고 병합하는 것은 주요 병목이 될 수 있음.
3. 애플리케이션 측의 추가 로직, 메모리 등이 필요할 수도 있고.
4. 따라서, RC는 다수의 노드에 있는 동일한 키-값 쌍에 대해 버전 충돌을 허용하지 않음.
5. 어떤 기술적 제약이 있는 것이 아님. CRDT나 동기 레플리케이션 상태 머신 등도 레디스와 비슷한 데이터 타입을 가질 수 있음. 그러나 속도는 느려지게 됨.

## Overview of Redis Cluster main components

### Keys distribution model

1. 키 영역은 16,384개의 슬럿으로 나뉨.
2. 이론적으로 최대 16384개의 마스터 노드를 가질 수 있는 것. 하지만, 최대 1,000개가 권장됨.
3. 클러스터 재설정이 진행중이 아니라면 클러스터는 안정적<sup>stable</sup>.
4. 클러스터가 안정적이면, 하나의 해시 슬럿은 하나의 노드에 의해서만 제공.
5. 키를 해시 슬럿에 대응시키는 알고리즘은 `HASH_SLOT = CRC16(key) mod 16384`.
6. CRC16의 출력 비트 중 14개만이 사용되며, 이것이 16384를 mod 연산한 이유.
7. 자신들의 테스트에서는 CRC16이 다양한 키들을 매우 고르게 분산했다고 함.

### Keys hash tags

1. 해시 슬럿 계산의 예외는 바로 해시 태그.
2. 다수의 키를 같은 해시 슬럿에 할당시키는 방법.
3. RC에서의 멀티-키 연산을 구현하기 위해 사용됨.
4. 키 안에 "{…}" 패턴이 포함되면 해시 태그가 동작.
5. 패턴에 대한 설명을 몇 개의 문장과 예시로 설명하고 있는데 아래 코드로 이해하는 게 제일 좋음.

```ruby
def HASH_SLOT(key)
    s = key.index "{"
    if s
        e = key.index "}",s+1
        if e && e != s+1
            key = key[s+1..e-1]
        end
    end
    crc16(key) % 16384
end
```

### Cluster nodes attributes

1. 모든 노드는 클러스터에서 유일한 이름을 가짐.
2. 노드의 이름은 160 비트 임의 숫자의 16진수 표현.
3. 한 번 정해지면 노드의 설정 파일에 저장되고, 시스템 관리자에 의해 설정 파일이 지워지거나, [CLUSTER RESET](https://redis.io/commands/cluster-reset) 커맨드에 의해 하드 리셋이 요청되기 전까지 계속 유지됨.
4. 클러스터에서 노드를 식별하기 위해 사용되며, 노드 ID 변경 없이 IP 주소를 바꾸는 것도 가능.
5. 이 ID는 노드가 가지는 유일한 정보는 아니지만, 전역적으로 일관성을 항상 유지하는 유일한 속성.
6. 모든 노드는 다른 노드에 대한 정보도 가짐. 노드 ID, IP, 포트, 플래그 집합, `slave`로 플래그 되어 있다면 마스터 노드는 누구인지, 노드가 ping 된 마지막 시간은 언제인지, 언제 pong을 받았는지, 현재 *configuration epoch*, ... 자세한 내용은 [CLUSTER NODES](https://redis.io/commands/cluster-nodes) 참고.
7. 이런 정보는 노드에 `CLUSTER NODES` 명령을 던지면 알 수 있음. 아래는 노드 정보의 형식과 예시.

```
-- 형식
<id> <ip:port> <flags> <master> <ping-sent> <pong-recv> <config-epoch> <link-state> <slot> <slot> ... <slot>

-- 예시
07c37dfeb235213a872192d90877d0cd55635b91 127.0.0.1:30004 slave e7d1eecce10fd6bb5eb35b9f99a514335d9ba9ca 0 1426238317239 4 connected
67ed2db8d677e59ec4a4cefb06858cf2a1a89fa1 127.0.0.1:30002 master - 0 1426238316232 2 connected 5461-10922
292f8b365bb7edb5e285caf0b7e6ddc7265d2f4f 127.0.0.1:30003 master - 0 1426238318243 3 connected 10923-16383
6ec23923021cf3ffec47632106199cb7f496ce01 127.0.0.1:30005 slave 67ed2db8d677e59ec4a4cefb06858cf2a1a89fa1 0 1426238316232 5 connected
824fe116063bc5fcf9f4ffd895bc17aee7731ac3 127.0.0.1:30006 slave 292f8b365bb7edb5e285caf0b7e6ddc7265d2f4f 0 1426238317741 6 connected
e7d1eecce10fd6bb5eb35b9f99a514335d9ba9ca 127.0.0.1:30001 myself,master - 0 0 1 connected 0-5460
```

### The Cluster bus

1. 모든 RC 노드는 다른 RC 노드와 연결되기 위한 추가적 TCP 포트를 가짐.
2. 일반 커맨드 포트에 10,000을 더하는 것이 강제됨.
3. 노드 대 노드 커뮤니케이션은 이 클러스터 버스와 클러스터 버스 프로토콜을 통해 이뤄짐.
4. 외부 소프트웨어 디바이스와 통신하기 위한 목적이 아니므로 공식 문서화 되어 있지는 않음. 코드 볼 것.

### Cluster topology

1. RC는 완전한 메쉬<sup>full mesh</sup>. TCP 커넥션을 이용해 모든 다른 노드들과 연결되어 있음.
2. 클러스터에서 N 노드들은 N-1개의 아웃바운드 TCP 연결을, 그리고 N-1 개의 인바운드 커넥션을 가짐.
3. 이 연결은 항상 살아있는 상태를 유지. 필요할 때마다 생성되는 것이 아님.
4. 다만, pong 응답이 오지 않을 때, 노드를 도달 불가하다고 판단할 만큼 기다리는 대신, 재연결을 시도.
5. RC 노드들은 완전한 메쉬를 구성. 하지만, 정상인 경우의 노드 간 많은 메시지 교환을 피하기 위해, 가십 프로토콜을 사용. 교환 메시지가 기하급수적으로 늘어나지는 않게 됨.
6. 가십 프로토콜은 [여기](https://1ambda.github.io/cloud-computing/cloud-computing-2/) 설명이 잘 나와있음.

### Nodes handshake

1. 노드는 클러스터 버스 포트의 연결을 항상 받아들임.
2. 신뢰할 수 없는 노드로부터의 ping에도 응답을 함.
3. 그러나, 노드가 클러스트의 일부가 아니라고 판단되면, 그 노드로부터 받은 ping 이외의 모든 패킷을 버림.
4. 하나의 노드는 다른 노드가 클러스터의 일부인지를 다음의 2가지 방식으로 판단.
   - `CLUSTER MEET ip port`. PING과 같지만, 어드민에 의해서만 가능하고, 클러스터의 일부로 받아들이는 것을 강제하는 점에서 다름.
   - 가십에 의해 다른 노드로부터 이미 신뢰된 노드임을 알게 되는 경우.

## Redirection and resharding

### MOVED Redirection

1. 레디스 클라이언트는 클러스터의 어느 노드에나 질의를 던질 수 있음.
2. 노드는 질의가 수용 가능한지 판단. 단일 키만 질의에 포함되거나, 다수의 키라고 하더라도 같은 해시 슬럿에 포함되었는가.
3. 만약, 자신이 응답할 수 있다면 바로 처리.
4. 그렇지 않다면 내부 매핑(해시 슬럿 - 노드) 정보를 체크한 뒤 아래와 같은 MOVED 에러 응답.
```
GET x
-MOVED 3999 127.0.0.1:6381
```
5. 이 응답을 받은 클라이언트는 해당 노드로 질의를 재발행.
6. 에러 응답과 재발행 사이에 클러스터 구성이 바뀔 수 있으며, 이 때는 또 MOVED 응답을 받을 수 있음.
7. 클라이언트는 3999가 127.0.0.1:6381에 의해 제공된다는 것을 기억해야 한다고 함. 올바른 노드를 찾을 가능성이 높아지므로.
8. [CLUSTER NODES](https://redis.io/commands/cluster-nodes)나 [CLUSTER SLOTS](https://redis.io/commands/cluster-slots) 명령어를 이용해 전체 클러스터 정보를 갱신할 수도 있음.
9. 리다이렉션이 일어나면, 많은 슬럿들이 재구성 되었을 가능성이 높고, 따라서 가능한 빨리 갱신해 주는 것이 좋음.

