
# An introduction to Redis data types and abstractions

레디스는 *plain key-value store*가 아니라, 여러 종류의 값들을 지원하는 *data structures server*. 전통적인 키-값 저장소에서는 문자열 키를 문자열 값들에 대응 시켰음. 레디스에서는 여기에 국한되지 않고, 더 복잡한 데이터 구조체를 유지할 수 있음. 아래는 레디스가 지원하는 데이터 구조체들.

- Binary-safe strings.
- Lists
    - 문자열 원소들의 집합.
    - 삽입된 순서대로 정렬.
    - 기본적으로는 링크드 리스트.
- Sets
    - 고유한, 정렬되지 않은 문자열 원소들의 집합.
- Sorted Sets
    - 기본적으로는 Set과 유사하지만,
    - 모든 문자열 원소들이 부동소수점<sup>floating</sup> 숫자 값에 대응.
    - 이 숫자는 스코어<sup>score</sup>라고 불림.
    - 모든 원소들은 항상 자신의 스코어 대로 정렬되어 있음.
    - 최상위 10개와 같은 특정 범위의 원소들을 조회할 수 있음.
- Hashes
    - 값들에 대응된 필드로 구성된 맵.
    - 필드와 값 모두 문자열.
    - Ruby나 Python의 해시와 매우 비슷.
- Bit arrays(또는 단순히 bitmaps)
    - 특수 커맨드들을 이용하면, 문자열 값을 비트의 배열로 다룰 수 있음.
    - 각 비트에 값을 할당하고 제거.
    - 1이 할당된 비트 갯수를 세거나, 1이 설정/해제된 가장 앞 쪽의 비트를 찾는 등의 일들이 가능.
- HyperLogLogs
    - 집합의 카디널리티를 추정하기 위한 확률적 데이터 구조체.
- Streams
    - 맵 같은 엔트리의 추가만 가능한<sup>append-only</sup> 집합.
    - 로그 데이터 타입의 추상화를 제공.

## Redis keys

레디스 키는 binary safe. 어떤 바이너리 시퀀스도 키로 사용할 수 있음을 의미. "foo" 같은 단순한 문자열부터 JPEG 파일 컨텐츠까지 다양. 빈 문자열 또한 유효한 키. 아래는 키에 대한 몇 가지 규칙.

- 매우 긴 키는 권장 X. 예컨대, 1024 바이트의 키 사용은 메모리 사용 측면에서 비효율. 또한, 데이터 셋 안에서의 키의 검색<sup>lookup</sup>에 값 비싼 키 비교 비용이 들어감. 단지 큰 값이 존재여부를 매칭하는 일이라고 하더라도, 메모리와 대역폭 관점에서, 이를 해싱해서 사용하는 것이 좋음.
- 매우 짧은 키 역시 나쁜 선택일 수도. 예를 들어, `user:1000:followers` 대신 `u1000flw`를 키로 사용하는 것은 별로 의미가 없음. 전자가 더 가독성이 좋고, 약간의 공간 사용 증가는 마이너한 요소. 더 짧은 키가 더 적은 비트를 사용하겠지만, 균형을 잡는 것이 우리의 몫.
- 스키마를 지키자. `object-type:id`와 같은 형태를 사용. 그리고 마침표나 대시를 사용해서 여러 단어로 이뤄진 필드에 사용. `comment:1234:reply.to` 또는 `comment:1234:reply-to`와 같이.
- 키 사이즈의 최대치는 512 MB.

## Redis Strings

- 레디스 키에 대응해서 사용하는 가장 단순한 타입.
- Memcahced에서의 유일한 데이터 타입.
- 레디스 키가 문자열이므로, 값으로도 문자열을 사용하면, 문자열을 다른 문자열에 매핑하는 것.
- 문자열 타입은 HTML 프래그먼트나 페이지 캐싱 등의 여러 경우에 유용.

```
> set mykey somevalue
OK
> get mykey
"somevalue"
```

- `SET`과 `GET` 커맨드를 이용해서 문자열 값을 설정하고 불러옴.
- 이미 있는 키에 대한 `SET`이면 값을 덮어 씀.
- 기존 값이 문자열이 아닌 값이라고 하더라도 대체 됨에 유의.
- 어떤 종류의 문자열(바이너리 데이터 포함)이든 값으로 저장할 수 있음.
- 예컨대 JPEG 이미지도 저장 가능.
- 값은 512 MB를 넘을 수 없음.
- `SET` 옵션 중에 `NX`는 키가 없는 경우에만,
- `XX`는 값이 이미 있는 경우에만 값을 설정함을 가리킴.

```
> set mykey newval nx
(nil)
> set mykey newval xx
OK
```

- 문자열에 대해 `INCR`, `INCRBY`, `DECR`, `DECRBY`를 사용하기도.
- 이들 커맨드는 모두 원자적<sup>atomic</sup>.

```
> set counter 100
OK
> incr counter
(integer) 101
> incr counter
(integer) 102
> incrby counter 50
(integer) 152
```

- `GETSET` 커맨드는 새로운 값을 할당하면서 기존의 값을 반환.
- 이 커맨드의 사용 예시는 다음과 같음. 웹 사이트에 매번 새로운 방문자가 들어올 때마다 `INCR` 명령어로 카운팅을 하고, 한 시간에 한 번씩 `GETSET`을 통해 갯수를 수집하고 동시에 값을 초기화.
- `MSET`, `MGET`은 여러 값을 한 번에 설정하고 조회.

```
> mset a 10 b 20 c 30
OK
> mget a b c
1) "10"
2) "20"
3) "30"
```
